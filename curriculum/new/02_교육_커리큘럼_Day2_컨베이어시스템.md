# ğŸ“… Day 2: ì»¨ë² ì´ì–´ ìë™ ë¶„ë¥˜ ì‹œìŠ¤í…œ (8ì‹œê°„)

> **"ì„¼ì„œë¡œ ê°ì§€í•˜ê³ , ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ íŒë³„í•˜ê³ , ìë™ìœ¼ë¡œ ë¶„ë¥˜í•œë‹¤"**  
> 8ë‹¨ê³„ë¡œ ì™„ì„±í•˜ëŠ” ìŠ¤ë§ˆíŠ¸ íŒ©í† ë¦¬ ì»¨ë² ì´ì–´ ì‹œìŠ¤í…œ + ì›ê²© ëª¨ë‹ˆí„°ë§

---

## ğŸ¯ Day 2 í•™ìŠµ ëª©í‘œ

### ìµœì¢… ëª©í‘œ

```mermaid
graph LR
    SENSOR[ì„¼ì„œ<br/>í•™ìŠµ] --> ACTUATOR[ì•¡ì¶”ì—ì´í„°<br/>ì œì–´]
    ACTUATOR --> COLOR[ìƒ‰ìƒ íŒë³„<br/>ì•Œê³ ë¦¬ì¦˜]
    COLOR --> INTEGRATED[í†µí•©<br/>ìë™ ë¶„ë¥˜]
    INTEGRATED --> COMM[ì´ì¤‘ í†µì‹ <br/>count_]
    COMM --> MONITOR[ì›ê²©<br/>ëª¨ë‹ˆí„°ë§]
    
    style SENSOR fill:#99E9F2,color:#111
    style COLOR fill:#FFD93D,color:#111
    style INTEGRATED fill:#FFA94D,color:#111
    style COMM fill:#51CF66,color:#fff
```

### í•™ìŠµ ì„±ê³¼

- âœ… **ì„¼ì„œ ë§ˆìŠ¤í„°**: IR, ì»¬ëŸ¬ ì„¼ì„œ ì™„ë²½ ì´í•´
- âœ… **ëª¨í„° ì œì–´**: DC ëª¨í„°, ì„œë³´ ëª¨í„° ì •ë°€ ì œì–´
- âœ… **í•µì‹¬ ì•Œê³ ë¦¬ì¦˜**: ìƒ‰ìƒ íŒë³„ (ìœ í´ë¦¬ë“œ ê±°ë¦¬)
- âœ… **ìë™í™” ì‹œìŠ¤í…œ**: ì™„ì „ ìë™ ë¶„ë¥˜ (~2,188ì¤„)
- âœ… **ì´ì¤‘ í†µì‹ **: Serial + Bluetooth ë™ì‹œ ì²˜ë¦¬
- âœ… **ì›ê²© ëª¨ë‹ˆí„°ë§**: count_ ë°ì´í„° ì‹¤ì‹œê°„ ì „ì†¡

---

## â° Day 2 ì‹œê°„í‘œ (8ì‹œê°„)

| êµì‹œ | ì‹œê°„ | í™œë™ | í•™ìŠµ ë‚´ìš© | ì‚°ì¶œë¬¼ |
|------|------|------|----------|--------|
| **1êµì‹œ** | 1h | í•˜ë“œì›¨ì–´ ì¡°ë¦½ | ì»¨ë² ì´ì–´ ì¡°ë¦½ + ì„¼ì„œ ì¥ì°© | ì‘ë™í•˜ëŠ” ì»¨ë² ì´ì–´ |
| **2êµì‹œ** | 1h | 01~02ë‹¨ê³„ | IR ì„¼ì„œ + ì»¬ëŸ¬ ì„¼ì„œ â­ | ìƒ‰ìƒ íŒë³„ |
| **3êµì‹œ** | 1h | 03~05ë‹¨ê³„ | RGB LED + DC + Servo | ì•¡ì¶”ì—ì´í„° ì œì–´ |
| **4êµì‹œ** | 1.5h | 06ë‹¨ê³„ â­â­ | í†µí•© ìë™ ë¶„ë¥˜ ì‹œìŠ¤í…œ | ìë™ ë¶„ë¥˜ |
| **5êµì‹œ** | 1.5h | 07ë‹¨ê³„ â­â­ | Serial ì‹¤ì‹œê°„ ì œì–´ | ë¹„ì°¨ë‹¨ ëª…ë ¹ |
| **6êµì‹œ** | 1h | 08ë‹¨ê³„ â­â­â­ | ì´ì¤‘ í†µì‹  + count_ | ì œí’ˆ ì¹´ìš´íŒ… |
| **7êµì‹œ** | 1h | ì•±ì¸ë²¤í„° ğŸ“± | ì›ê²© ëª¨ë‹ˆí„°ë§ ì•± | ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ |

---

## 1êµì‹œ: ğŸ”§ ì»¨ë² ì´ì–´ ì‹œìŠ¤í…œ ì¡°ë¦½ (1ì‹œê°„)

### ğŸ“¦ ë¶€í’ˆ í™•ì¸

```mermaid
mindmap
  root((ì»¨ë² ì´ì–´<br/>ì‹œìŠ¤í…œ))
    ì„¼ì„œ
      IR ì„¼ì„œ
      TCS34725 ì»¬ëŸ¬
      ì´ˆìŒíŒŒ ì˜µì…˜
    ëª¨í„°
      DC ëª¨í„° 12V
      L298N ë“œë¼ì´ë²„
      ì„œë³´ SG90
    LED
      NeoPixel
      WS2812B Ã— 3ê°œ
      RGB ì œì–´
    ì œì–´
      ì•„ë‘ì´ë…¸
      ë¸”ë£¨íˆ¬ìŠ¤ HC-06
      5V 12V ì „ì›
    ê¸°êµ¬
      ë²¨íŠ¸
      í”„ë ˆì„
      ê²Œì´íŠ¸
```

### ğŸ› ï¸ ì¡°ë¦½ í”„ë¡œì„¸ìŠ¤

#### Step 1: í”„ë ˆì„ ë° ë²¨íŠ¸ ì¡°ë¦½ (20ë¶„)

```mermaid
graph LR
    FRAME[í”„ë ˆì„<br/>ì¡°ë¦½] --> BELT[ë²¨íŠ¸<br/>ì¥ì°©]
    BELT --> MOTOR[DC ëª¨í„°<br/>ê³ ì •]
    MOTOR --> PULLEY[í’€ë¦¬<br/>ì—°ê²°]
    
    style FRAME fill:#FFE3E0,color:#111
    style MOTOR fill:#FFD93D,color:#111
```

**ì²´í¬ í¬ì¸íŠ¸**:
- [ ] ë²¨íŠ¸ê°€ íŒ½íŒ½í•˜ê²Œ ì¥ì°©ë˜ì—ˆë‚˜?
- [ ] í’€ë¦¬ê°€ ë²¨íŠ¸ì™€ ì˜ ë§ë¬¼ë¦¬ë‚˜?
- [ ] DC ëª¨í„°ê°€ ë‹¨ë‹¨íˆ ê³ ì •ë˜ì—ˆë‚˜?

#### Step 2: ì„¼ì„œ ë°°ì¹˜ (15ë¶„)

```mermaid
graph TD
    START[ì‹œì‘ì ] --> IR[IR ì„¼ì„œ<br/>ì¤‘ê°„ ì§€ì ]
    IR --> COLOR[ì»¬ëŸ¬ ì„¼ì„œ<br/>ê°ì§€ ìœ„ì¹˜]
    COLOR --> GATE[ì„œë³´ ê²Œì´íŠ¸<br/>ë¶„ë¥˜ ì§€ì ]
    
    style IR fill:#99E9F2,color:#111
    style COLOR fill:#FFD93D,color:#111
    style GATE fill:#FFA94D,color:#111
```

**ì„¼ì„œ ìœ„ì¹˜ ê°€ì´ë“œ**:
- **IR ì„¼ì„œ**: ë²¨íŠ¸ ì¤‘ê°„, ë¬¼ì²´ê°€ ì§€ë‚˜ê°€ëŠ” ê³³
- **ì»¬ëŸ¬ ì„¼ì„œ**: IR ê°ì§€ í›„ 10cm ì§€ì , ìœ„ì—ì„œ ì•„ë˜ë¡œ
- **ì„œë³´ ê²Œì´íŠ¸**: ì»¬ëŸ¬ ì„¼ì„œ í›„ 15cm, ë¶„ë¥˜ ì‹œì‘ ì§€ì 

#### Step 3: ë°°ì„  (25ë¶„)

```mermaid
graph TD
    ARD[ì•„ë‘ì´ë…¸<br/>UNO] --> SENSOR_GRP[ì„¼ì„œ ê·¸ë£¹]
    ARD --> MOTOR_GRP[ëª¨í„° ê·¸ë£¹]
    ARD --> LED_GRP[LED ê·¸ë£¹]
    ARD --> BT[ë¸”ë£¨íˆ¬ìŠ¤]
    
    SENSOR_GRP --> IR[IR: D2]
    SENSOR_GRP --> COLOR[Color: SDA,SCL]
    
    MOTOR_GRP --> L298N[L298N]
    L298N --> DC[DC: D3,D4,D5]
    MOTOR_GRP --> SERVO[Servo: D6]
    
    LED_GRP --> NEO[NeoPixel: D7]
    
    style ARD fill:#FF6B6B,color:#fff
    style L298N fill:#FFD93D,color:#111
```

**ë°°ì„  ì²´í¬ë¦¬ìŠ¤íŠ¸**:

| ë¶€í’ˆ | ì•„ë‘ì´ë…¸ í•€ | ì¶”ê°€ ì—°ê²° | í™•ì¸ |
|------|------------|---------|------|
| **IR ì„¼ì„œ** | D2 (Digital) | VCC â†’ 5V, GND | â–¡ |
| **ì»¬ëŸ¬ ì„¼ì„œ SDA** | A4 (I2C) | í’€ì—… ì €í•­ | â–¡ |
| **ì»¬ëŸ¬ ì„¼ì„œ SCL** | A5 (I2C) | í’€ì—… ì €í•­ | â–¡ |
| **ì»¬ëŸ¬ ì„¼ì„œ LED** | 3.3V | ë°ê¸° ì¡°ì ˆ | â–¡ |
| **L298N IN1** | D3 | ë°©í–¥ ì œì–´ | â–¡ |
| **L298N IN2** | D4 | ë°©í–¥ ì œì–´ | â–¡ |
| **L298N ENA** | D5 (PWM) | ì†ë„ ì œì–´ | â–¡ |
| **DC ëª¨í„°** | L298N OUT1,OUT2 | 12V ì „ì› | â–¡ |
| **ì„œë³´ ê²Œì´íŠ¸** | D6 (PWM) | VCC â†’ 5V | â–¡ |
| **NeoPixel DIN** | D7 | ì²«ë²ˆì§¸ LED | â–¡ |
| **NeoPixel VCC** | 5V | ì „ì²´ ì—°ê²° | â–¡ |
| **ë¸”ë£¨íˆ¬ìŠ¤ RX** | TX (D1) | Serial ì—°ê²° | â–¡ |
| **ë¸”ë£¨íˆ¬ìŠ¤ TX** | RX (D0) | Serial ì—°ê²° | â–¡ |

---

## 2êµì‹œ: ğŸ“¡ 01~02ë‹¨ê³„ - ì„¼ì„œ í•™ìŠµ (1ì‹œê°„)

### 01ë‹¨ê³„: IR ì„¼ì„œ (20ë¶„)

**í•™ìŠµ ëª©í‘œ**: ì ì™¸ì„  ì„¼ì„œë¡œ ë¬¼ì²´ ê°ì§€

#### ê°ì§€ ì•Œê³ ë¦¬ì¦˜

```mermaid
graph TD
    START[ì‹œì‘] --> READ[IR ì„¼ì„œ<br/>ì½ê¸°]
    READ --> CHECK{ì‹ í˜¸<br/>LOW?}
    CHECK -->|Yes| DEBOUNCE[ë””ë°”ìš´ì‹±<br/>50ms]
    CHECK -->|No| WAIT[ëŒ€ê¸°<br/>100ms]
    
    DEBOUNCE --> VERIFY{ì—¬ì „íˆ<br/>LOW?}
    VERIFY -->|Yes| DETECTED[ë¬¼ì²´ ê°ì§€<br/>í™•ì •]
    VERIFY -->|No| WAIT
    
    WAIT --> READ
    DETECTED --> LED[LED ON]
    LED --> WAIT_OBJ[ë¬¼ì²´<br/>ì§€ë‚˜ê°]
    WAIT_OBJ --> LED_OFF[LED OFF]
    LED_OFF --> READ
    
    style DETECTED fill:#51CF66,color:#fff
```

#### í•µì‹¬ ì½”ë“œ

```cpp
const int IR_PIN = 2;
bool objectDetected = false;

void loop() {
  int irValue = digitalRead(IR_PIN);
  
  if(irValue == LOW && !objectDetected) {
    // ë””ë°”ìš´ì‹±
    delay(50);
    if(digitalRead(IR_PIN) == LOW) {
      objectDetected = true;
      Serial.println("ë¬¼ì²´ ê°ì§€!");
      digitalWrite(LED_BUILTIN, HIGH);
    }
  } else if(irValue == HIGH && objectDetected) {
    objectDetected = false;
    Serial.println("ë¬¼ì²´ í†µê³¼");
    digitalWrite(LED_BUILTIN, LOW);
  }
  
  delay(100);
}
```

### 02ë‹¨ê³„: ì»¬ëŸ¬ ì„¼ì„œ â­ (40ë¶„)

**í•™ìŠµ ëª©í‘œ**: TCS34725ë¡œ RGB ìƒ‰ìƒ íŒë³„í•˜ëŠ” í•µì‹¬ ì•Œê³ ë¦¬ì¦˜ ë§ˆìŠ¤í„°

#### ìƒ‰ìƒ íŒë³„ ì•Œê³ ë¦¬ì¦˜ (ìœ í´ë¦¬ë“œ ê±°ë¦¬)

```mermaid
graph LR
    START[ì‹œì‘] --> MEASURE[RGB<br/>ì¸¡ì •]
    MEASURE --> NORMALIZE[ì •ê·œí™”<br/>0-255]
    NORMALIZE --> CALC[ìœ í´ë¦¬ë“œ ê±°ë¦¬<br/>ê³„ì‚°]
    
    CALC --> D_RED[d_red<br/>ê¸°ì¤€ê°’ê³¼ ê±°ë¦¬]
    CALC --> D_GREEN[d_green<br/>ê¸°ì¤€ê°’ê³¼ ê±°ë¦¬]
    CALC --> D_BLUE[d_blue<br/>ê¸°ì¤€ê°’ê³¼ ê±°ë¦¬]
    
    D_RED & D_GREEN & D_BLUE --> MIN[ìµœì†Œ ê±°ë¦¬<br/>ì°¾ê¸°]
    MIN --> RESULT[ìƒ‰ìƒ<br/>ê²°ì •]
    
    style MEASURE fill:#99E9F2,color:#111
    style CALC fill:#FFD93D,color:#111
    style RESULT fill:#51CF66,color:#fff
```

#### ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³µì‹

$$
d = \sqrt{(R_{ì¸¡ì •} - R_{ê¸°ì¤€})^2 + (G_{ì¸¡ì •} - G_{ê¸°ì¤€})^2 + (B_{ì¸¡ì •} - B_{ê¸°ì¤€})^2}
$$

#### ê¸°ì¤€ ìƒ‰ìƒ ê°’ (ìº˜ë¦¬ë¸Œë ˆì´ì…˜)

```cpp
// ê¸°ì¤€ ìƒ‰ìƒ ê°’ (ì¸¡ì • í›„ ì…ë ¥)
struct ColorRef {
  int r, g, b;
};

ColorRef RED_REF    = {255, 50, 50};   // ë¹¨ê°•
ColorRef GREEN_REF  = {50, 255, 50};   // ì´ˆë¡
ColorRef BLUE_REF   = {50, 50, 255};   // íŒŒë‘
ColorRef YELLOW_REF = {255, 255, 50};  // ë…¸ë‘

// ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³„ì‚°
float distance(int r1, int g1, int b1, int r2, int g2, int b2) {
  int dr = r1 - r2;
  int dg = g1 - g2;
  int db = b1 - b2;
  return sqrt(dr*dr + dg*dg + db*db);
}
```

#### ìƒ‰ìƒ íŒë³„ ì•Œê³ ë¦¬ì¦˜ (ì‹¤ì œ êµ¬í˜„)

**ìƒ‰ìƒ íŒë³„ ìˆœì„œë„**:
```mermaid
graph TD
    START[ìƒ‰ìƒ ì„¼ì„œ<br/>ë°ì´í„° ìš”ì²­] --> READ[getRawData<br/>rawR,rawG,rawB,rawC]
    READ --> PRINT_RAW[Serial ì¶œë ¥:<br/>Raw ê°’]
    
    PRINT_RAW --> MAP_R[r = map<br/>rawR, 0~21504 â†’ 0~1000]
    MAP_R --> MAP_G[g = map<br/>rawG, 0~21504 â†’ 0~1000]
    MAP_G --> MAP_B[b = map<br/>rawB, 0~21504 â†’ 0~1000]
    
    MAP_B --> PRINT_MAPPED[Serial ì¶œë ¥:<br/>Mapped RGB]
    
    PRINT_MAPPED --> COMPARE1{r > g<br/>&&<br/>r > b?}
    COMPARE1 -->|Yes| RESULT_RED[colorName = ë¹¨ê°„ìƒ‰<br/>servoAngle = 30Â°<br/>LED = 255,0,0]
    
    COMPARE1 -->|No| COMPARE2{g > r<br/>&&<br/>g > b?}
    COMPARE2 -->|Yes| RESULT_GREEN[colorName = ì´ˆë¡ìƒ‰<br/>servoAngle = 57Â°<br/>LED = 0,255,0]
    
    COMPARE2 -->|No| RESULT_BLUE[colorName = íŒŒë€ìƒ‰<br/>servoAngle = 2Â°<br/>LED = 0,0,255]
    
    RESULT_RED & RESULT_GREEN & RESULT_BLUE --> PRINT_COLOR[Serial ì¶œë ¥:<br/>íŒë³„ ìƒ‰ìƒ]
    
    PRINT_COLOR --> RETURN[ë°˜í™˜:<br/>angle, LED RGB]
    
    style START fill:#99E9F2,color:#111
    style COMPARE1 fill:#FFD93D,color:#111
    style COMPARE2 fill:#FFA94D,color:#111
    style RESULT_RED fill:#FF6B6B,color:#fff
    style RESULT_GREEN fill:#51CF66,color:#fff
    style RESULT_BLUE fill:#4DABF7,color:#fff
```

**ì‹¤ì œ ì½”ë“œ (ë‹¨ìˆœí™” ë²„ì „)**:
```cpp
#include <Wire.h>
#include <Adafruit_TCS34725.h>

Adafruit_TCS34725 colorSensor = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X);

const int RAW_MAX = 21504;
const int MAPPED_MAX = 1000;
const int MIN_SUM = 15;  // ìœ íš¨ ìƒ‰ìƒ ìµœì†Œ í•©ê³„

void loop() {
  // 1. Raw ë°ì´í„° ì½ê¸°
  uint16_t rawR, rawG, rawB, rawC;
  colorSensor.getRawData(&rawR, &rawG, &rawB, &rawC);
  
  Serial.print("Raw -> R: ");
  Serial.print(rawR);
  Serial.print(", G: ");
  Serial.print(rawG);
  Serial.print(", B: ");
  Serial.println(rawB);
  
  // 2. ì •ê·œí™” (0-1000)
  int r = map(rawR, 0, RAW_MAX, 0, MAPPED_MAX);
  int g = map(rawG, 0, RAW_MAX, 0, MAPPED_MAX);
  int b = map(rawB, 0, RAW_MAX, 0, MAPPED_MAX);
  
  Serial.print("RGB -> R: ");
  Serial.print(r);
  Serial.print(", G: ");
  Serial.print(g);
  Serial.print(", B: ");
  Serial.println(b);
  
  // 3. ìœ íš¨ì„± ì²´í¬
  int sum = r + g + b;
  if(sum < MIN_SUM) {
    Serial.println("ìƒ‰ìƒ ì—†ìŒ (ë°°ê²½)");
    return;
  }
  
  // 4. ìµœëŒ€ê°’ ë¹„êµë¡œ ìƒ‰ìƒ íŒë³„
  int ledR = 0, ledG = 0, ledB = 0;
  int servoAngle = 2;  // ê¸°ë³¸: íŒŒë‘
  const char* colorName = "ì•Œ ìˆ˜ ì—†ìŒ";
  
  if (r > g && r > b) {
    // ë¹¨ê°„ìƒ‰
    colorName = "ë¹¨ê°„ìƒ‰";
    servoAngle = 30;
    ledR = 255; ledG = 0; ledB = 0;
  } 
  else if (g > r && g > b) {
    // ì´ˆë¡ìƒ‰
    colorName = "ì´ˆë¡ìƒ‰";
    servoAngle = 57;
    ledR = 0; ledG = 255; ledB = 0;
  } 
  else {
    // íŒŒë€ìƒ‰ (ê¸°ë³¸)
    colorName = "íŒŒë€ìƒ‰";
    servoAngle = 2;
    ledR = 0; ledG = 0; ledB = 255;
  }
  
  Serial.print("íŒë³„ ìƒ‰ìƒ: ");
  Serial.println(colorName);
  
  // 5. ì„œë³´ ë° LED ì œì–´
  controlServo(servoAngle);
  controlLED(ledR, ledG, ledB);
}
```

**ê³ ê¸‰ ë²„ì „ (ìœ í´ë¦¬ë“œ ê±°ë¦¬)**:
```cpp
struct ColorRef {
  int r, g, b;
};

ColorRef RED_REF    = {255, 50, 50};   // ë¹¨ê°•
ColorRef GREEN_REF  = {50, 255, 50};   // ì´ˆë¡
ColorRef BLUE_REF   = {50, 50, 255};   // íŒŒë‘

// ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³„ì‚°
float distance(int r1, int g1, int b1, int r2, int g2, int b2) {
  int dr = r1 - r2;
  int dg = g1 - g2;
  int db = b1 - b2;
  return sqrt(dr*dr + dg*dg + db*db);
}

String detectColorAdvanced(int r, int g, int b) {
  // ê° ê¸°ì¤€ ìƒ‰ìƒê³¼ì˜ ê±°ë¦¬ ê³„ì‚°
  float d_red = distance(r, g, b, RED_REF.r, RED_REF.g, RED_REF.b);
  float d_green = distance(r, g, b, GREEN_REF.r, GREEN_REF.g, GREEN_REF.b);
  float d_blue = distance(r, g, b, BLUE_REF.r, BLUE_REF.g, BLUE_REF.b);
  
  // ìµœì†Œ ê±°ë¦¬ ì°¾ê¸°
  float minDist = d_red;
  String color = "RED";
  
  if(d_green < minDist) {
    minDist = d_green;
    color = "GREEN";
  }
  if(d_blue < minDist) {
    minDist = d_blue;
    color = "BLUE";
  }
  
  Serial.print("ê±°ë¦¬ -> R:");
  Serial.print(d_red);
  Serial.print(" G:");
  Serial.print(d_green);
  Serial.print(" B:");
  Serial.println(d_blue);
  Serial.print("íŒë³„ â†’ ");
  Serial.println(color);
  
  return color;
}
```

**ì‹œê°„ ë³µì¡ë„**: O(1) (ë¹„êµ ì—°ì‚° 3íšŒ ê³ ì •)

**ê³µê°„ ë³µì¡ë„**: O(1) (ë³€ìˆ˜ ìˆ˜ ê³ ì •)

**ì‹¤ìŠµ í™œë™**:
1. [ ] ë¹¨ê°• ë¬¼ì²´ ì¸¡ì • â†’ ê¸°ì¤€ê°’ ì €ì¥
2. [ ] ì´ˆë¡ ë¬¼ì²´ ì¸¡ì • â†’ ê¸°ì¤€ê°’ ì €ì¥
3. [ ] íŒŒë‘ ë¬¼ì²´ ì¸¡ì • â†’ ê¸°ì¤€ê°’ ì €ì¥
4. [ ] í…ŒìŠ¤íŠ¸: ì •í™•ë„ 80% ì´ìƒ í™•ì¸

---

## 3êµì‹œ: âš™ï¸ 03~05ë‹¨ê³„ - ì•¡ì¶”ì—ì´í„° ì œì–´ (1ì‹œê°„)

### 03ë‹¨ê³„: RGB LED (15ë¶„)

**í•™ìŠµ ëª©í‘œ**: NeoPixelë¡œ 15ê°€ì§€ ìƒ‰ìƒ í‘œì‹œ

#### NeoPixel ì œì–´

```cpp
#include <Adafruit_NeoPixel.h>

#define LED_PIN 7
#define LED_COUNT 3

Adafruit_NeoPixel strip(LED_COUNT, LED_PIN, NEO_GRB + NEO_KHZ800);

void setup() {
  strip.begin();
  strip.setBrightness(50);  // ë°ê¸° ì¡°ì ˆ
  strip.show();
}

void setColor(String color) {
  uint32_t c;
  
  if(color == "RED") {
    c = strip.Color(255, 0, 0);
  } else if(color == "GREEN") {
    c = strip.Color(0, 255, 0);
  } else if(color == "BLUE") {
    c = strip.Color(0, 0, 255);
  } else if(color == "YELLOW") {
    c = strip.Color(255, 255, 0);
  } else {
    c = strip.Color(255, 255, 255);  // í°ìƒ‰ (ê¸°ë³¸)
  }
  
  // ëª¨ë“  LEDë¥¼ ê°™ì€ ìƒ‰ìœ¼ë¡œ
  for(int i = 0; i < LED_COUNT; i++) {
    strip.setPixelColor(i, c);
  }
  strip.show();
}
```

### 04ë‹¨ê³„: DC ëª¨í„° (25ë¶„)

**í•™ìŠµ ëª©í‘œ**: L298Nìœ¼ë¡œ PWM ì†ë„ ì œì–´

#### PWM ì œì–´ ì•Œê³ ë¦¬ì¦˜ (ì„¸ë¶€ ì„¤ëª…)

```mermaid
graph LR
    START[ì‹œì‘] --> SETUP[í•€ ëª¨ë“œ ì„¤ì •<br/>IN1,IN2: OUTPUT<br/>ENA: PWM]
    
    SETUP --> SET_DIR[ë°©í–¥ ì„¤ì •<br/>IN1=HIGH<br/>IN2=LOW]
    
    SET_DIR --> ACCEL_START[ê°€ì† ì‹œì‘<br/>speed=0]
    ACCEL_START --> ACCEL_LOOP{speed<br/><120?}
    ACCEL_LOOP -->|Yes| ACCEL_INC[speed += 10<br/>analogWrite ENA]
    ACCEL_INC --> ACCEL_DELAY[delay 50ms]
    ACCEL_DELAY --> ACCEL_LOOP
    
    ACCEL_LOOP -->|No| RUN[ì •ì† ìš´í–‰<br/>speed=120]
    RUN --> RUN_LOOP[analogWrite<br/>ENA, 120]
    
    RUN_LOOP --> CHECK_IR{IR ê°ì§€?}
    CHECK_IR -->|No| RUN_LOOP
    
    CHECK_IR -->|Yes| DECEL_START[ê°ì† ì‹œì‘]
    DECEL_START --> DECEL_LOOP{speed<br/>>0?}
    DECEL_LOOP -->|Yes| DECEL_DEC[speed -= 10<br/>analogWrite ENA]
    DECEL_DEC --> DECEL_DELAY[delay 30ms]
    DECEL_DELAY --> DECEL_LOOP
    
    DECEL_LOOP -->|No| STOP[ì™„ì „ ì •ì§€<br/>speed=0<br/>analogWrite 0]
    
    STOP --> PROCESS[ì œí’ˆ ì²˜ë¦¬]
    PROCESS --> ACCEL_START
    
    style START fill:#99E9F2,color:#111
    style RUN fill:#51CF66,color:#fff
    style STOP fill:#FF6B6B,color:#fff
    style CHECK_IR fill:#FFD93D,color:#111
```

#### ì‹¤ì œ ì½”ë“œ (í†µí•© ë²„ì „)

```cpp
// í•€ ì„¤ì •
const int PIN_MOTOR_DIR = 13;    // ë°©í–¥
const int PIN_MOTOR_SPEED = 11;  // PWM ì†ë„
const int MOTOR_SPEED = 120;     // ì •ì† ì†ë„
const int MOTOR_DIR_FORWARD = HIGH;

void setup() {
  pinMode(PIN_MOTOR_DIR, OUTPUT);
  pinMode(PIN_MOTOR_SPEED, OUTPUT);
  
  // ë°©í–¥ ì„¤ì • (ì „ì§„)
  digitalWrite(PIN_MOTOR_DIR, MOTOR_DIR_FORWARD);
  analogWrite(PIN_MOTOR_SPEED, 0);  // ì´ˆê¸°: ì •ì§€
}

void loop() {
  // ì»¨ë² ì´ì–´ ì‹œì‘
  analogWrite(PIN_MOTOR_SPEED, MOTOR_SPEED);
  
  // IR ì„¼ì„œ ê°ì§€ ëŒ€ê¸°
  while(digitalRead(PIN_IR_SENSOR) == HIGH) {
    delay(10);  // ê°ì§€ ëŒ€ê¸°
  }
  
  // ì œí’ˆ ê°ì§€ â†’ ì •ì§€
  analogWrite(PIN_MOTOR_SPEED, 0);
  delay(2000);  // ì²˜ë¦¬ ì‹œê°„
  
  // ìƒ‰ìƒ ì„¼ì„œë¡œ ì´ë™
  analogWrite(PIN_MOTOR_SPEED, MOTOR_SPEED);
  // (ìƒ‰ìƒ ê°ì§€ ë£¨í”„...)
  
  // ë‹¤ì‹œ ì •ì§€
  analogWrite(PIN_MOTOR_SPEED, 0);
  delay(1500);  // ë¶„ë¥˜ ì‹œê°„
  
  // ì¬ì‹œì‘
  analogWrite(PIN_MOTOR_SPEED, MOTOR_SPEED);
  delay(1000);  // ë‹¤ìŒ ì œí’ˆ ê°„ê²©
}
```

#### ë¶€ë“œëŸ¬ìš´ ê°€ê°ì† (ì„ íƒ ì‚¬í•­)

```cpp
// ë¶€ë“œëŸ¬ìš´ ê°€ì†
void motorAccelerate(int targetSpeed) {
  int currentSpeed = 0;
  while(currentSpeed < targetSpeed) {
    currentSpeed += 10;
    if(currentSpeed > targetSpeed) currentSpeed = targetSpeed;
    
    analogWrite(PIN_MOTOR_SPEED, currentSpeed);
    delay(50);  // ê°€ì† ê³¡ì„ 
  }
}

// ë¶€ë“œëŸ¬ìš´ ê°ì†
void motorDecelerate() {
  int currentSpeed = MOTOR_SPEED;
  while(currentSpeed > 0) {
    currentSpeed -= 10;
    if(currentSpeed < 0) currentSpeed = 0;
    
    analogWrite(PIN_MOTOR_SPEED, currentSpeed);
    delay(30);  // ê°ì† ê³¡ì„ 
  }
}
```

**PWM ë“€í‹° ì‚¬ì´í´ ì´í•´**:
```
0%   duty cycle (0/255)   â†’ 0V   â†’ ì •ì§€
25%  duty cycle (64/255)  â†’ 1.25V â†’ ëŠë¦¼
50%  duty cycle (128/255) â†’ 2.5V  â†’ ì¤‘ê°„
75%  duty cycle (192/255) â†’ 3.75V â†’ ë¹ ë¦„
100% duty cycle (255/255) â†’ 5V   â†’ ìµœê³ ì†
```

**ì‹œê°„ ë³µì¡ë„**: 
- ê°€ì†: O(n), n = targetSpeed / 10
- ì •ì†: O(1)
- ê°ì†: O(n), n = currentSpeed / 10

**ì£¼ì˜ì‚¬í•­**:
1. **ê³¼ë¶€í•˜ ë°©ì§€**: ê¸‰ê°€ì† ê¸ˆì§€ (ëª¨í„° ë³´í˜¸)
2. **ì „ë¥˜ ì œí•œ**: 2A ì´ìƒ ì „ì› í•„ìˆ˜
3. **PWM ì£¼íŒŒìˆ˜**: ~490Hz (Arduino ê¸°ë³¸)

// ë¶€ë“œëŸ¬ìš´ ê°€ì†
void motorAccelerate() {
  for(int speed = 0; speed <= 255; speed += 5) {
    analogWrite(ENA, speed);
    delay(50);
  }
}

// ë¶€ë“œëŸ¬ìš´ ê°ì†
void motorDecelerate() {
  for(int speed = 255; speed >= 0; speed -= 5) {
    analogWrite(ENA, speed);
    delay(50);
  }
}
```

### 05ë‹¨ê³„: ì„œë³´ ê²Œì´íŠ¸ (20ë¶„)

**í•™ìŠµ ëª©í‘œ**: ì„œë³´ë¡œ ë¶„ë¥˜ ë°©í–¥ ì œì–´

#### ê²Œì´íŠ¸ ì œì–´ ì•Œê³ ë¦¬ì¦˜ (ì‹¤ì œ êµ¬í˜„ ê¸°ë°˜)

```mermaid
graph TD
    START[ìƒ‰ìƒ íŒë³„<br/>ì™„ë£Œ] --> ATTACH[servo.attach<br/>PIN_SERVO]
    
    ATTACH --> CHECK_COLOR{ìƒ‰ìƒ íŒë³„}
    
    CHECK_COLOR -->|ë¹¨ê°•| ANGLE_RED[ê°ë„ 30Â°<br/>ì™¼ìª½ ë¶„ë¥˜]
    CHECK_COLOR -->|ì´ˆë¡| ANGLE_GREEN[ê°ë„ 57Â°<br/>ì¤‘ì•™ í†µê³¼]
    CHECK_COLOR -->|íŒŒë‘| ANGLE_BLUE[ê°ë„ 2Â°<br/>ì˜¤ë¥¸ìª½ ë¶„ë¥˜]
    
    ANGLE_RED & ANGLE_GREEN & ANGLE_BLUE --> WRITE[servo.write<br/>ê°ë„]
    
    WRITE --> WAIT1[delay 500ms<br/>ì„œë³´ ì´ë™ ì™„ë£Œ]
    
    WAIT1 --> LED_SHOW[LED í‘œì‹œ<br/>3ê°œ í”½ì…€]
    
    LED_SHOW --> WAIT2[delay 1500ms<br/>ë¶„ë¥˜ ì‹œê°„ í™•ë³´]
    
    WAIT2 --> DETACH[servo.detach<br/>ì „ë ¥ ì ˆì•½]
    
    DETACH --> MOTOR_ON[ì»¨ë² ì´ì–´ ì¬ê°€ë™]
    
    style START fill:#99E9F2,color:#111
    style CHECK_COLOR fill:#FFD93D,color:#111
    style ANGLE_RED fill:#FF6B6B,color:#fff
    style ANGLE_GREEN fill:#51CF66,color:#fff
    style ANGLE_BLUE fill:#4DABF7,color:#fff
    style DETACH fill:#FFA94D,color:#111
```

#### ì‹¤ì œ ì½”ë“œ (í†µí•© ë²„ì „)

```cpp
#include <Servo.h>

Servo servo;
const int PIN_SERVO = 9;

// ì‹¤ì œ ì¸¡ì •ëœ ê°ë„ (í•˜ë“œì›¨ì–´ ì¢…ì†)
const int ANGLE_RED = 30;    // ë¹¨ê°•: ì™¼ìª½
const int ANGLE_GREEN = 57;  // ì´ˆë¡: ì¤‘ì•™
const int ANGLE_BLUE = 2;    // íŒŒë‘: ì˜¤ë¥¸ìª½

void setup() {
  // ì„œë³´ ì´ˆê¸°í™” (3ê°œ ê°ë„ í…ŒìŠ¤íŠ¸)
  servo.attach(PIN_SERVO);
  servo.write(ANGLE_RED);
  delay(500);
  servo.write(ANGLE_GREEN);
  delay(500);
  servo.write(ANGLE_BLUE);
  servo.detach();  // ë–¨ë¦¼ ë°©ì§€
}

void loop() {
  // (ìƒ‰ìƒ íŒë³„ ì™„ë£Œ í›„...)
  
  // 1. ì„œë³´ í™œì„±í™”
  servo.attach(PIN_SERVO);
  
  // 2. ìƒ‰ìƒì— ë”°ë¥¸ ê°ë„ ì„¤ì •
  int servoAngle;
  int ledR, ledG, ledB;
  
  if (r > g && r > b) {
    // ë¹¨ê°„ìƒ‰
    servoAngle = ANGLE_RED;
    ledR = 255; ledG = 0; ledB = 0;
    Serial.println("ë¹¨ê°„ìƒ‰ â†’ 30Â° (ì™¼ìª½)");
  } 
  else if (g > r && g > b) {
    // ì´ˆë¡ìƒ‰
    servoAngle = ANGLE_GREEN;
    ledR = 0; ledG = 255; ledB = 0;
    Serial.println("ì´ˆë¡ìƒ‰ â†’ 57Â° (ì¤‘ì•™)");
  } 
  else {
    // íŒŒë€ìƒ‰
    servoAngle = ANGLE_BLUE;
    ledR = 0; ledG = 0; ledB = 255;
    Serial.println("íŒŒë€ìƒ‰ â†’ 2Â° (ì˜¤ë¥¸ìª½)");
  }
  
  // 3. ì„œë³´ ì´ë™
  servo.write(servoAngle);
  delay(500);  // ì´ë™ ì™„ë£Œ ëŒ€ê¸°
  
  // 4. LED í‘œì‹œ
  for (int i = 0; i < NUM_PIXELS; i++) {
    led.setPixelColor(i, led.Color(ledR, ledG, ledB));
  }
  led.show();
  
  delay(1500);  // ë¶„ë¥˜ ì‹œê°„
  
  // 5. ì„œë³´ ë¶„ë¦¬ (ì „ë ¥ ì ˆì•½ + ë–¨ë¦¼ ë°©ì§€)
  servo.detach();
  
  // 6. ì»¨ë² ì´ì–´ ì¬ê°€ë™
  analogWrite(PIN_MOTOR_SPEED, MOTOR_SPEED);
  delay(1000);
}
```

#### ì„œë³´ ê°ë„ ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë„êµ¬

```cpp
// ê°ë„ í…ŒìŠ¤íŠ¸ í”„ë¡œê·¸ë¨
void testServoAngles() {
  Serial.println("=== ì„œë³´ ê°ë„ í…ŒìŠ¤íŠ¸ ===");
  
  servo.attach(PIN_SERVO);
  
  // 0-180Â° ì „ì²´ ë²”ìœ„ í…ŒìŠ¤íŠ¸
  for(int angle = 0; angle <= 180; angle += 10) {
    Serial.print("ê°ë„: ");
    Serial.println(angle);
    
    servo.write(angle);
    delay(1000);  // 1ì´ˆì”© í™•ì¸
  }
  
  servo.detach();
  
  Serial.println("í…ŒìŠ¤íŠ¸ ì™„ë£Œ");
  Serial.println("ìµœì  ê°ë„ë¥¼ í™•ì¸í•˜ê³  ì½”ë“œì— ë°˜ì˜í•˜ì„¸ìš”:");
  Serial.println("- ë¹¨ê°• â†’ ì™¼ìª½ ë¶„ë¥˜ ê°ë„: ?");
  Serial.println("- ì´ˆë¡ â†’ ì¤‘ì•™ í†µê³¼ ê°ë„: ?");
  Serial.println("- íŒŒë‘ â†’ ì˜¤ë¥¸ìª½ ë¶„ë¥˜ ê°ë„: ?");
}
```

**ì‹œê°„ ë³µì¡ë„**: O(1) (ê³ ì • ì‹œê°„)

**ì¤‘ìš” ê°œë…**:
1. **attach/detach**: ì„œë³´ ì‚¬ìš© ì‹œë§Œ í™œì„±í™” (ë–¨ë¦¼ ë°©ì§€, ì „ë ¥ ì ˆì•½)
2. **delay 500ms**: ì„œë³´ ë¬¼ë¦¬ì  ì´ë™ ì‹œê°„ í™•ë³´
3. **í•˜ë“œì›¨ì–´ ìº˜ë¦¬ë¸Œë ˆì´ì…˜**: ì‹¤ì œ ê°ë„ëŠ” ì¸¡ì • í•„ìš” (30Â°, 57Â°, 2Â°)

**ë””ë²„ê¹… íŒ**:
```cpp
// ê°ë„ ì„¤ì • í›„ í™•ì¸
servo.write(angle);
delay(15);  // ì„œë³´ ì‹ í˜¸ ì•ˆì •í™”
int currentAngle = servo.read();
Serial.print("ì„¤ì • ê°ë„: ");
Serial.print(angle);
Serial.print(" / í˜„ì¬ ê°ë„: ");
Serial.println(currentAngle);
```

---

## 4êµì‹œ: ğŸ”„ 06ë‹¨ê³„ - í†µí•© ìë™ ë¶„ë¥˜ â­â­ (1.5ì‹œê°„)

**í•™ìŠµ ëª©í‘œ**: ëª¨ë“  ëª¨ë“ˆì„ í†µí•©í•œ ì™„ì „ ìë™í™” ì‹œìŠ¤í…œ

### í†µí•© ì‹œìŠ¤í…œ í”Œë¡œìš°ì°¨íŠ¸

```mermaid
graph TD
    START[ì‹œìŠ¤í…œ ì‹œì‘] --> SETUP[setup í•¨ìˆ˜]
    SETUP --> INIT_MOTOR[ëª¨í„° ì´ˆê¸°í™”<br/>ë°©í–¥ ì „ì§„]
    INIT_MOTOR --> INIT_SERVO[ì„œë³´ ì´ˆê¸°í™”<br/>3ê°œ ê°ë„ í…ŒìŠ¤íŠ¸]
    INIT_SERVO --> INIT_COLOR[ì»¬ëŸ¬ ì„¼ì„œ<br/>begin ì²´í¬]
    INIT_COLOR --> CHECK_SENSOR{ì„¼ì„œ<br/>ì •ìƒ?}
    CHECK_SENSOR -->|No| ERROR[ë¬´í•œ ëŒ€ê¸°<br/>ì„¼ì„œ ì˜¤ë¥˜]
    
    CHECK_SENSOR -->|Yes| INIT_LED[LED ì´ˆê¸°í™”<br/>ë°ê¸° 255]
    INIT_LED --> BUZZER_START[ì‹œì‘ ì•Œë¦¼ìŒ<br/>523Hz, 659Hz]
    BUZZER_START --> MOTOR_ON[ëª¨í„° ê°€ë™<br/>PWM 120]
    
    MOTOR_ON --> LOOP_START[loop ì‹œì‘]
    
    LOOP_START --> IR_CHECK{IR ì„¼ì„œ<br/>HIGH?}
    IR_CHECK -->|Yes| LOOP_START
    
    IR_CHECK -->|No| PRODUCT_DETECT[ì œí’ˆ ê°ì§€!<br/>productCount++]
    PRODUCT_DETECT --> PRINT1[Serial ì¶œë ¥:<br/>ì œí’ˆ ë²ˆí˜¸]
    
    PRINT1 --> MOTOR_STOP1[ëª¨í„° ì •ì§€<br/>PWM 0]
    MOTOR_STOP1 --> BUZZER1[ì•Œë¦¼ìŒ<br/>523Hz, 784Hz]
    BUZZER1 --> DELAY1[ëŒ€ê¸°<br/>2000ms]
    
    DELAY1 --> MOTOR_MOVE[ëª¨í„° ì¬ì‹œì‘<br/>ì»¬ëŸ¬ ì„¼ì„œë¡œ ì´ë™]
    
    MOTOR_MOVE --> COLOR_LOOP[ìƒ‰ìƒ ì„¼ì„œ ì½ê¸°<br/>ë£¨í”„]
    COLOR_LOOP --> READ_RAW[getRawData<br/>rawR,G,B,C]
    READ_RAW --> MAP_RGB[map í•¨ìˆ˜<br/>0~21504 â†’ 0~1000]
    MAP_RGB --> CALC_SUM[sum = r+g+b]
    CALC_SUM --> CHECK_SUM{sum < 15?}
    CHECK_SUM -->|Yes| COLOR_LOOP
    
    CHECK_SUM -->|No| MOTOR_STOP2[ëª¨í„° ì •ì§€<br/>ìƒ‰ìƒ ë¶„ì„]
    MOTOR_STOP2 --> BUZZER2[ì•Œë¦¼ìŒ<br/>523Hz, 784Hz]
    
    BUZZER2 --> PRINT_RGB[Serial ì¶œë ¥:<br/>Raw & Mapped RGB]
    
    PRINT_RGB --> COLOR_COMPARE{RGB ë¹„êµ}
    COLOR_COMPARE -->|r>g && r>b| RED[ë¹¨ê°„ìƒ‰ íŒë³„]
    COLOR_COMPARE -->|g>r && g>b| GREEN[ì´ˆë¡ìƒ‰ íŒë³„]
    COLOR_COMPARE -->|else| BLUE[íŒŒë€ìƒ‰ íŒë³„]
    
    RED --> SET_RED[ì„œë³´ 30Â°<br/>LED 255,0,0]
    GREEN --> SET_GREEN[ì„œë³´ 57Â°<br/>LED 0,255,0]
    BLUE --> SET_BLUE[ì„œë³´ 2Â°<br/>LED 0,0,255]
    
    SET_RED & SET_GREEN & SET_BLUE --> SERVO_ATTACH[servo.attach]
    SERVO_ATTACH --> SERVO_WRITE[servo.write<br/>ê°ë„ ì„¤ì •]
    SERVO_WRITE --> SERVO_DELAY[ëŒ€ê¸° 500ms]
    
    SERVO_DELAY --> LED_SHOW[LED í‘œì‹œ<br/>3ê°œ í”½ì…€ ë™ì¼ ìƒ‰]
    LED_SHOW --> WAIT_COLOR[ëŒ€ê¸°<br/>1500ms]
    
    WAIT_COLOR --> SERVO_DETACH[servo.detach]
    SERVO_DETACH --> MOTOR_RESTART[ëª¨í„° ì¬ê°€ë™<br/>PWM 120]
    MOTOR_RESTART --> DELAY2[ëŒ€ê¸°<br/>1000ms]
    
    DELAY2 --> PRINT_DONE[Serial ì¶œë ¥:<br/>ì œí’ˆ ì²˜ë¦¬ ì™„ë£Œ]
    PRINT_DONE --> LOOP_START
    
    style START fill:#99E9F2,color:#111
    style COLOR_COMPARE fill:#FFD93D,color:#111
    style SET_RED fill:#FF6B6B,color:#fff
    style SET_GREEN fill:#51CF66,color:#fff
    style SET_BLUE fill:#4DABF7,color:#fff
    style LOOP_START fill:#FFA94D,color:#111
```

### ìƒíƒœ ë¨¸ì‹  ì„¤ê³„

```cpp
enum State {
  IDLE,        // ëŒ€ê¸°
  DETECTING,   // ë¬¼ì²´ ê°ì§€
  MEASURING,   // ìƒ‰ìƒ ì¸¡ì •
  SORTING,     // ë¶„ë¥˜ ì¤‘
  RESUMING     // ì¬ì‹œì‘
};

State currentState = IDLE;

void loop() {
  switch(currentState) {
    case IDLE:
      motorForward(200);  // ì •ì† ìš´í–‰
      
      if(digitalRead(IR_PIN) == LOW) {
        currentState = DETECTING;
      }
      break;
      
    case DETECTING:
      delay(50);  // ë””ë°”ìš´ì‹±
      if(digitalRead(IR_PIN) == LOW) {
        motorStop();
        currentState = MEASURING;
      } else {
        currentState = IDLE;
      }
      break;
      
    case MEASURING:
      delay(500);  // ì•ˆì •í™” ì‹œê°„
      String color = detectColor();
      setColor(color);
      currentState = SORTING;
      break;
      
    case SORTING:
      sortByColor(color);
      currentState = RESUMING;
      break;
      
    case RESUMING:
      delay(1000);
      setColor("OFF");
      currentState = IDLE;
      break;
  }
}
```

**ì‹¤ìŠµ í™œë™**:
- [ ] ë¹¨ê°• ë¬¼ì²´ â†’ ì™¼ìª½ ë¶„ë¥˜ í™•ì¸
- [ ] ì´ˆë¡ ë¬¼ì²´ â†’ ì¤‘ì•™ í†µê³¼ í™•ì¸
- [ ] íŒŒë‘ ë¬¼ì²´ â†’ ì˜¤ë¥¸ìª½ ë¶„ë¥˜ í™•ì¸
- [ ] ì—°ì† 10ê°œ â†’ ì •í™•ë„ 80% ì´ìƒ

---

## 5êµì‹œ: ğŸ“¡ 07ë‹¨ê³„ - Serial ì‹¤ì‹œê°„ ì œì–´ â­â­ (1.5ì‹œê°„)

**í•™ìŠµ ëª©í‘œ**: delay() ì¤‘ì—ë„ ëª…ë ¹ì„ ë°›ëŠ” ë¹„ì°¨ë‹¨ ì•Œê³ ë¦¬ì¦˜

### ë¬¸ì œ: delay()ì˜ í•œê³„

```mermaid
graph LR
    CMD[ëª…ë ¹ ìˆ˜ì‹ ] -.ë¸”ë¡.-> DELAY[delay<br/>1000ms]
    DELAY -.ë¸”ë¡.-> EXEC[ëª…ë ¹ ì‹¤í–‰]
    
    style DELAY fill:#FF6B6B,color:#fff
```

**ë¬¸ì œì **: `delay(1000)` ë™ì•ˆ ë‹¤ë¥¸ ëª…ë ¹ì„ ë°›ì„ ìˆ˜ ì—†ìŒ!

### í•´ê²°: millis() ë¹„ì°¨ë‹¨ íƒ€ì´ë°

```mermaid
graph TD
    LOOP_START[loop ì‹œì‘] --> CHECK_CMD{Serial<br/>available?}
    CHECK_CMD -->|Yes| READ_CMD[ëª…ë ¹ ì½ê¸°<br/>readStringUntil]
    CHECK_CMD -->|No| CHECK_TIME
    
    READ_CMD --> PARSE{ëª…ë ¹ íŒŒì‹±}
    PARSE -->|start| SET_RUN[systemRunning<br/>= true]
    PARSE -->|stop| SET_STOP[systemRunning<br/>= false<br/>motorStop]
    PARSE -->|init| RESET[resetSystem]
    
    SET_RUN & SET_STOP & RESET --> CHECK_TIME
    
    CHECK_TIME[currentTime<br/>= millis] --> CALC_ELAPSED[elapsed =<br/>currentTime - lastTime]
    
    CALC_ELAPSED --> CHECK_INTERVAL{elapsed<br/>>= INTERVAL<br/>&&<br/>systemRunning?}
    
    CHECK_INTERVAL -->|No| LOOP_START
    
    CHECK_INTERVAL -->|Yes| EXEC[ì£¼ê¸°ì  ì‘ì—…<br/>ìˆ˜í–‰]
    EXEC --> UPDATE_TIME[lastTime<br/>= currentTime]
    UPDATE_TIME --> LOOP_START
    
    style LOOP_START fill:#99E9F2,color:#111
    style CHECK_CMD fill:#FFD93D,color:#111
    style EXEC fill:#51CF66,color:#fff
    style CHECK_INTERVAL fill:#FFA94D,color:#111
```

### í•µì‹¬ ì•Œê³ ë¦¬ì¦˜: ì‹¤ì‹œê°„ ëª…ë ¹ ì²´í¬ (ì„¸ë¶€ ì„¤ëª…)

```cpp
// ì „ì—­ ë³€ìˆ˜
unsigned long lastTime = 0;           // ë§ˆì§€ë§‰ ì‘ì—… ì‹œê°„
const unsigned long INTERVAL = 1000;  // ì‘ì—… ì£¼ê¸° (1ì´ˆ)
bool systemRunning = false;           // ì‹œìŠ¤í…œ ë™ì‘ ìƒíƒœ

void loop() {
  // ========== 1ë‹¨ê³„: í•­ìƒ ëª…ë ¹ ì²´í¬ (ë¹„ì°¨ë‹¨) ==========
  checkSerialCommand();
  
  // ========== 2ë‹¨ê³„: íƒ€ì´ë° ì²´í¬ ==========
  unsigned long currentTime = millis();  // í˜„ì¬ ì‹œê°„ (ms)
  unsigned long elapsed = currentTime - lastTime;
  
  // ========== 3ë‹¨ê³„: ì¡°ê±´ ì¶©ì¡± ì‹œ ì‘ì—… ì‹¤í–‰ ==========
  if(systemRunning && (elapsed >= INTERVAL)) {
    performTask();  // ì£¼ê¸°ì  ì‘ì—…
    lastTime = currentTime;  // ì‹œê°„ ì—…ë°ì´íŠ¸
    
    Serial.print("ì‘ì—… ì‹¤í–‰: ");
    Serial.print(currentTime);
    Serial.print("ms (ê²½ê³¼: ");
    Serial.print(elapsed);
    Serial.println("ms)");
  }
  
  // loopëŠ” ì¦‰ì‹œ ì¬ì‹œì‘ â†’ Serial ì²´í¬ ë¹ˆë„ â†‘
}

void checkSerialCommand() {
  if(Serial.available() > 0) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    
    Serial.print("ëª…ë ¹ ìˆ˜ì‹ : ");
    Serial.println(cmd);
    
    if(cmd == "start_") {
      systemRunning = true;
      analogWrite(PIN_MOTOR_SPEED, MOTOR_SPEED);
      Serial.println("OK:START - ì‹œìŠ¤í…œ ê°€ë™");
    } 
    else if(cmd == "stop_") {
      systemRunning = false;
      analogWrite(PIN_MOTOR_SPEED, 0);
      Serial.println("OK:STOP - ì‹œìŠ¤í…œ ì •ì§€");
    } 
    else if(cmd == "init_") {
      systemRunning = false;
      resetSystem();
      Serial.println("OK:INIT - ì‹œìŠ¤í…œ ì´ˆê¸°í™”");
    }
    else if(cmd == "status_") {
      Serial.print("ìƒíƒœ: ");
      Serial.println(systemRunning ? "ë™ì‘ ì¤‘" : "ì •ì§€");
      Serial.print("ê°€ë™ ì‹œê°„: ");
      Serial.print(millis() / 1000);
      Serial.println("ì´ˆ");
    }
    else {
      Serial.println("ERR:UNKNOWN_COMMAND");
    }
  }
}

void performTask() {
  // ì£¼ê¸°ì  ì‘ì—… (ì˜ˆ: ì„¼ì„œ ì½ê¸°, ë°ì´í„° ì „ì†¡ ë“±)
  Serial.println("--- ì£¼ê¸°ì  ì‘ì—… ìˆ˜í–‰ ---");
  
  // ì˜ˆ: ì„¼ì„œ ë°ì´í„° ì½ê¸°
  int irValue = digitalRead(PIN_IR_SENSOR);
  Serial.print("IR ì„¼ì„œ: ");
  Serial.println(irValue == LOW ? "ê°ì§€ë¨" : "ì—†ìŒ");
  
  // ì˜ˆ: ìƒíƒœ ì „ì†¡
  Serial.print("STATUS:");
  Serial.print(millis());
  Serial.print(",");
  Serial.println(irValue);
}
```

### delay() vs millis() ë¹„êµ

| í•­ëª© | delay() | millis() |
|-----|---------|----------|
| **ë™ì‘ ë°©ì‹** | ì°¨ë‹¨ (blocking) | ë¹„ì°¨ë‹¨ (non-blocking) |
| **ëª…ë ¹ ìˆ˜ì‹ ** | âŒ delay ì¤‘ ë¶ˆê°€ëŠ¥ | âœ… í•­ìƒ ê°€ëŠ¥ |
| **ì •í™•ë„** | âœ… ì •í™• | âš ï¸ ì˜¤ì°¨ ëˆ„ì  ê°€ëŠ¥ |
| **ë³µì¡ë„** | ê°„ë‹¨ | ì•½ê°„ ë³µì¡ |
| **ì‚¬ìš© ì‚¬ë¡€** | ë‹¨ìˆœ ì‹œí€€ìŠ¤ | ì‹¤ì‹œê°„ ì œì–´ |

### millis() ì˜¤ë²„í”Œë¡œìš° ëŒ€ì±…

```cpp
// millis()ëŠ” ì•½ 49.7ì¼ í›„ ì˜¤ë²„í”Œë¡œìš° (0ìœ¼ë¡œ ë˜ëŒì•„ê°)
// ì˜¬ë°”ë¥¸ ê²½ê³¼ ì‹œê°„ ê³„ì‚°:
unsigned long elapsed = currentTime - lastTime;

// âœ… ì˜¤ë²„í”Œë¡œìš° ì•ˆì „ (unsigned ì—°ì‚° íŠ¹ì„±)
// ì˜ˆ: currentTime = 100, lastTime = 4294967290 (ì˜¤ë²„í”Œë¡œìš° ì§ì „)
//     elapsed = 100 - 4294967290 = 110 (ì˜¬ë°”ë¦„!)

// âŒ ì˜ëª»ëœ ë°©ë²•:
if(currentTime > lastTime + INTERVAL) {  // ì˜¤ë²„í”Œë¡œìš° ì‹œ ì˜¤ë™ì‘
  // ...
}
```

### ì‹¤ì „ ì‘ìš©: ë‹¤ì¤‘ íƒ€ì´ë¨¸

```cpp
unsigned long lastMotorTime = 0;
unsigned long lastSensorTime = 0;
unsigned long lastReportTime = 0;

const unsigned long MOTOR_INTERVAL = 100;    // ëª¨í„°: 100ms
const unsigned long SENSOR_INTERVAL = 50;    // ì„¼ì„œ: 50ms
const unsigned long REPORT_INTERVAL = 1000;  // ë¦¬í¬íŠ¸: 1ì´ˆ

void loop() {
  checkSerialCommand();
  
  unsigned long now = millis();
  
  // íƒ€ì´ë¨¸ 1: ëª¨í„° ì œì–´
  if(now - lastMotorTime >= MOTOR_INTERVAL) {
    controlMotor();
    lastMotorTime = now;
  }
  
  // íƒ€ì´ë¨¸ 2: ì„¼ì„œ ì½ê¸°
  if(now - lastSensorTime >= SENSOR_INTERVAL) {
    readSensors();
    lastSensorTime = now;
  }
  
  // íƒ€ì´ë¨¸ 3: ìƒíƒœ ë¦¬í¬íŠ¸
  if(now - lastReportTime >= REPORT_INTERVAL) {
    sendStatusReport();
    lastReportTime = now;
  }
}
```

**ì‹œê°„ ë³µì¡ë„**: O(1) (ëª¨ë“  íƒ€ì´ë° ì²´í¬)

**ê³µê°„ ë³µì¡ë„**: O(n), n = íƒ€ì´ë¨¸ ê°œìˆ˜

### ëª…ë ¹ì–´ í…Œì´ë¸”

| ëª…ë ¹ì–´ | ê¸°ëŠ¥ | ì‘ë‹µ |
|--------|------|------|
| `start_` | ì‹œìŠ¤í…œ ì‹œì‘ | `OK:START` |
| `stop_` | ì¦‰ì‹œ ì¤‘ì§€ | `OK:STOP` |
| `init_` | ì´ˆê¸°í™” | `OK:INIT` |
| `speed_200_` | ì†ë„ ë³€ê²½ | `OK:SPEED_200` |

---

## 6êµì‹œ: ğŸ“Š 08ë‹¨ê³„ - ì´ì¤‘ í†µì‹  + count_ â­â­â­ (1ì‹œê°„)

**í•™ìŠµ ëª©í‘œ**: Serial + Bluetooth ë™ì‹œ ì²˜ë¦¬ + ì œí’ˆ ì¹´ìš´íŒ…

### ì´ì¤‘ í†µì‹  êµ¬ì¡°

```mermaid
graph TD
    SERIAL[Serial<br/>PC] --> ARD[ì•„ë‘ì´ë…¸]
    BT[Bluetooth<br/>ìŠ¤ë§ˆíŠ¸í°] --> ARD
    
    ARD --> PROCESS[ëª…ë ¹ ì²˜ë¦¬<br/>ìš°ì„ ìˆœìœ„]
    PROCESS --> EXEC[ì‹¤í–‰]
    EXEC --> RESP_S[Serial ì‘ë‹µ]
    EXEC --> RESP_B[Bluetooth ì‘ë‹µ]
    
    style ARD fill:#FFD93D,color:#111
    style PROCESS fill:#51CF66,color:#fff
```

### ì œí’ˆ ì¹´ìš´í„° ì•Œê³ ë¦¬ì¦˜

```cpp
struct ProductCounter {
  int red;
  int green;
  int blue;
  int yellow;
  int total;
};

ProductCounter counter = {0, 0, 0, 0, 0};

void updateCounter(String color) {
  counter.total++;
  
  if(color == "RED") {
    counter.red++;
    sendCountData("red", counter.red);
  } else if(color == "GREEN") {
    counter.green++;
    sendCountData("green", counter.green);
  } else if(color == "BLUE") {
    counter.blue++;
    sendCountData("blue", counter.blue);
  } else if(color == "YELLOW") {
    counter.yellow++;
    sendCountData("yellow", counter.yellow);
  }
}

void sendCountData(String color, int count) {
  String msg = "count_" + color + String(count) + "_";
  
  // Serialê³¼ Bluetooth ëª¨ë‘ ì „ì†¡
  Serial.println(msg);
  
  if(bluetoothConnected) {
    Serial.print(msg);  // BluetoothëŠ” Serial ê³µìœ 
  }
}
```

### count_ ë°ì´í„° í˜•ì‹

| ë°ì´í„° | í˜•ì‹ | ì˜ë¯¸ | ì˜ˆì‹œ |
|--------|------|------|------|
| ë¹¨ê°• 1ê°œ | `count_red1_` | ë¹¨ê°• ì¹´ìš´í„° = 1 | `count_red1_` |
| ì´ˆë¡ 2ê°œ | `count_green2_` | ì´ˆë¡ ì¹´ìš´í„° = 2 | `count_green2_` |
| íŒŒë‘ 3ê°œ | `count_blue3_` | íŒŒë‘ ì¹´ìš´í„° = 3 | `count_blue3_` |
| ì „ì²´ í†µê³„ | `count_total15_` | ì´ 15ê°œ ì²˜ë¦¬ | `count_total15_` |

**ì‹¤ìŠµ í™œë™**:
- [ ] start_ ëª…ë ¹ìœ¼ë¡œ ì‹œì‘
- [ ] ìƒ‰ìƒë³„ë¡œ 5ê°œì”© íˆ¬ì…
- [ ] count_ ë°ì´í„° ìˆ˜ì‹  í™•ì¸
- [ ] stop_ ëª…ë ¹ìœ¼ë¡œ ì¤‘ì§€

---

## 7êµì‹œ: ğŸ“± ì›ê²© ëª¨ë‹ˆí„°ë§ ì•± (1ì‹œê°„)

**í•™ìŠµ ëª©í‘œ**: ì•±ì¸ë²¤í„°ë¡œ ì‹¤ì‹œê°„ ì¬ê³  í˜„í™© ëª¨ë‹ˆí„°ë§

### ì•± í™”ë©´ êµ¬ì„±

```mermaid
graph TD
    SCREEN[Screen1] --> CONN[Bluetooth<br/>ì—°ê²° ë²„íŠ¼]
    SCREEN --> STATUS[ìƒíƒœ í‘œì‹œ<br/>Label]
    SCREEN --> CHART[ì‹¤ì‹œê°„ ì°¨íŠ¸<br/>Canvas]
    SCREEN --> COUNTER[ì¹´ìš´í„°<br/>Label Ã— 4]
    SCREEN --> CONTROL[ì œì–´ ë²„íŠ¼<br/>start/stop/init]
    
    style SCREEN fill:#FFE3E3,color:#111
    style CHART fill:#FFD93D,color:#111
```

### ë¸”ë¡ ì½”ë”©: count_ ë°ì´í„° íŒŒì‹± (ì•Œê³ ë¦¬ì¦˜ ìƒì„¸)

**ë°ì´í„° íŒŒì‹± ìˆœì„œë„**:
```mermaid
graph TD
    START[BluetoothClient1<br/>AfterReceive] --> RECEIVE[data = ReceiveText-1]
    
    RECEIVE --> PRINT1[Label_Logì—<br/>raw data í‘œì‹œ]
    
    PRINT1 --> CHECK_RED{contains<br/>data, 'count_red'<br/>?}
    CHECK_RED -->|Yes| EXTRACT_RED[number =<br/>extractNumber data]
    EXTRACT_RED --> UPDATE_RED[lblRedCount.Text<br/>= number]
    UPDATE_RED --> CHART_RED[updateChart<br/>RED, number]
    
    CHECK_RED -->|No| CHECK_GREEN{contains<br/>data, 'count_green'<br/>?}
    CHECK_GREEN -->|Yes| EXTRACT_GREEN[number =<br/>extractNumber data]
    EXTRACT_GREEN --> UPDATE_GREEN[lblGreenCount.Text<br/>= number]
    UPDATE_GREEN --> CHART_GREEN[updateChart<br/>GREEN, number]
    
    CHECK_GREEN -->|No| CHECK_BLUE{contains<br/>data, 'count_blue'<br/>?}
    CHECK_BLUE -->|Yes| EXTRACT_BLUE[number =<br/>extractNumber data]
    EXTRACT_BLUE --> UPDATE_BLUE[lblBlueCount.Text<br/>= number]
    UPDATE_BLUE --> CHART_BLUE[updateChart<br/>BLUE, number]
    
    CHECK_BLUE -->|No| CHECK_TOTAL{contains<br/>data, 'count_total'<br/>?}
    CHECK_TOTAL -->|Yes| EXTRACT_TOTAL[number =<br/>extractNumber data]
    EXTRACT_TOTAL --> UPDATE_TOTAL[lblTotalCount.Text<br/>= number]
    UPDATE_TOTAL --> UPDATE_PERCENT[updatePercentage<br/>í˜¸ì¶œ]
    
    CHECK_TOTAL -->|No| CHECK_OK{contains<br/>data, 'OK:'<br/>?}
    CHECK_OK -->|Yes| STATUS_OK[lblStatus.Text<br/>= data<br/>ìƒ‰ìƒ: ì´ˆë¡]
    
    CHECK_OK -->|No| CHECK_ERR{contains<br/>data, 'ERR:'<br/>?}
    CHECK_ERR -->|Yes| STATUS_ERR[lblStatus.Text<br/>= data<br/>ìƒ‰ìƒ: ë¹¨ê°•]
    
    CHECK_ERR -->|No| UNKNOWN[Unknown ë©”ì‹œì§€<br/>ë¬´ì‹œ]
    
    CHART_RED & CHART_GREEN & CHART_BLUE & UPDATE_PERCENT & STATUS_OK & STATUS_ERR & UNKNOWN --> END[ëŒ€ê¸°]
    
    style START fill:#99E9F2,color:#111
    style CHECK_RED fill:#FFD93D,color:#111
    style CHECK_GREEN fill:#FFA94D,color:#111
    style CHART_RED fill:#FF6B6B,color:#fff
    style CHART_GREEN fill:#51CF66,color:#fff
    style CHART_BLUE fill:#4DABF7,color:#fff
```

**ë¸”ë¡ ì½”ë”© (ì˜ì‚¬ì½”ë“œ)**:
```
ğŸ“ when BluetoothClient1.AfterReceive
  â”œâ”€ set data to BluetoothClient1.ReceiveText(-1)
  â”‚
  â”œâ”€ set Label_Log.Text to "ìˆ˜ì‹ : " + data  // ë””ë²„ê¹…ìš©
  â”‚
  â”œâ”€ if contains(data, "count_red")
  â”‚   â”œâ”€ set number to extractNumber(data)
  â”‚   â”œâ”€ set lblRedCount.Text to number
  â”‚   â”œâ”€ set lblRedCount.BackgroundColor to RED
  â”‚   â””â”€ call updateChart("RED", number)
  â”‚
  â”œâ”€ else if contains(data, "count_green")
  â”‚   â”œâ”€ set number to extractNumber(data)
  â”‚   â”œâ”€ set lblGreenCount.Text to number
  â”‚   â”œâ”€ set lblGreenCount.BackgroundColor to GREEN
  â”‚   â””â”€ call updateChart("GREEN", number)
  â”‚
  â”œâ”€ else if contains(data, "count_blue")
  â”‚   â”œâ”€ set number to extractNumber(data)
  â”‚   â””â”€ set lblBlueCount.Text to number
  â”‚
  â””â”€ else if contains(data, "count_total")
      â”œâ”€ set number to extractNumber(data)
      â””â”€ set lblTotalCount.Text to number
```

### ìˆ«ì ì¶”ì¶œ í”„ë¡œì‹œì € (ì•Œê³ ë¦¬ì¦˜ ìƒì„¸)

**ìˆ«ì ì¶”ì¶œ ìˆœì„œë„**:
```mermaid
graph TD
    START[extractNumber<br/>text ì…ë ¥] --> EXAMPLE[ì˜ˆ: count_red5_]
    
    EXAMPLE --> FIND_FIRST[indexOf<br/>text, '_']
    FIND_FIRST --> ADD_ONE[start = index + 1]
    
    ADD_ONE --> FIND_LAST[lastIndexOf<br/>text, '_']
    FIND_LAST --> RESULT[end = index]
    
    RESULT --> SUBSTRING[numberPart =<br/>substring<br/>start to end]
    SUBSTRING --> EXAMPLE2[ì˜ˆ: 'red5']
    
    EXAMPLE2 --> INIT_RESULT[result = '']
    INIT_RESULT --> LOOP_START[for each char<br/>in numberPart]
    
    LOOP_START --> CHECK_DIGIT{isDigit<br/>char?}
    CHECK_DIGIT -->|Yes| APPEND[result += char]
    CHECK_DIGIT -->|No| SKIP[ê±´ë„ˆë›°ê¸°]
    
    APPEND & SKIP --> LOOP_CHECK{ë” ìˆìŒ?}
    LOOP_CHECK -->|Yes| LOOP_START
    LOOP_CHECK -->|No| CONVERT[convertToNumber<br/>result]
    
    CONVERT --> RETURN[return number<br/>ì˜ˆ: 5]
    
    style START fill:#99E9F2,color:#111
    style SUBSTRING fill:#FFD93D,color:#111
    style CHECK_DIGIT fill:#FFA94D,color:#111
    style RETURN fill:#51CF66,color:#fff
```

**ë¸”ë¡ ì½”ë”© (ìƒì„¸)**:
```
ğŸ“ procedure extractNumber (text)
  parameters: text
  result: number
  
  // ì˜ˆ: text = "count_red5_"
  
  // 1ë‹¨ê³„: ì²« ë²ˆì§¸ _ ì°¾ê¸°
  set firstUnderscoreIndex to call text.indexOf("_")
  // firstUnderscoreIndex = 5
  
  set start to firstUnderscoreIndex + 1
  // start = 6 (rì˜ ìœ„ì¹˜)
  
  // 2ë‹¨ê³„: ë§ˆì§€ë§‰ _ ì°¾ê¸°
  set lastUnderscoreIndex to call text.lastIndexOf("_")
  // lastUnderscoreIndex = 9
  
  set end to lastUnderscoreIndex - start + 1
  // end = 4 (ê¸¸ì´)
  
  // 3ë‹¨ê³„: ë¶€ë¶„ ë¬¸ìì—´ ì¶”ì¶œ
  set numberPart to call text.substring(start, end)
  // numberPart = "red5"
  
  // 4ë‹¨ê³„: ìˆ«ìë§Œ ì¶”ì¶œ
  set result to ""
  set i to 1
  
  repeat while i <= length of numberPart
    set char to call text.charAt(i)
    
    if char >= "0" and char <= "9" then
      set result to join(result, char)
    
    set i to i + 1
  
  // result = "5"
  
  // 5ë‹¨ê³„: ë¬¸ìì—´ â†’ ìˆ«ì ë³€í™˜
  if result = "" then
    return 0
  else
    return convertToNumber(result)
```

**ì‹œê°„ ë³µì¡ë„**: O(n), n = text ê¸¸ì´

**í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤**:
| ì…ë ¥ | ì¶œë ¥ |
|------|------|
| `"count_red5_"` | 5 |
| `"count_green12_"` | 12 |
| `"count_blue0_"` | 0 |
| `"count_total123_"` | 123 |

### ì‹¤ì‹œê°„ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ (ì•Œê³ ë¦¬ì¦˜ ìƒì„¸)

**ì°¨íŠ¸ ì—…ë°ì´íŠ¸ ìˆœì„œë„**:
```mermaid
graph TD
    START[updateChart<br/>color, number] --> GET_COUNTS[redCount = lblRedCount<br/>greenCount = lblGreenCount<br/>blueCount = lblBlueCount]
    
    GET_COUNTS --> CALC_TOTAL[total =<br/>red + green + blue]
    
    CALC_TOTAL --> CHECK_ZERO{total<br/>== 0?}
    CHECK_ZERO -->|Yes| SKIP[ì—…ë°ì´íŠ¸ ê±´ë„ˆë›°ê¸°]
    
    CHECK_ZERO -->|No| CALC_PERCENT[redPercent = red/totalÃ—100<br/>greenPercent = green/totalÃ—100<br/>bluePercent = blue/totalÃ—100]
    
    CALC_PERCENT --> CLEAR[Canvas.Clear]
    
    CLEAR --> DRAW_RED[Canvas.DrawCircle<br/>ë¹¨ê°• ì›í˜•<br/>0 ~ redPercent]
    DRAW_RED --> DRAW_GREEN[Canvas.DrawCircle<br/>ì´ˆë¡ ì›í˜•<br/>redPercent ~ redPercent+greenPercent]
    DRAW_GREEN --> DRAW_BLUE[Canvas.DrawCircle<br/>íŒŒë‘ ì›í˜•<br/>ë‚˜ë¨¸ì§€]
    
    DRAW_BLUE --> TEXT_RED[Canvas.DrawText<br/>ë¹¨ê°•: Xê°œ<br/>Y%]
    TEXT_RED --> TEXT_GREEN[Canvas.DrawText<br/>ì´ˆë¡: Xê°œ<br/>Y%]
    TEXT_GREEN --> TEXT_BLUE[Canvas.DrawText<br/>íŒŒë‘: Xê°œ<br/>Y%]
    
    TEXT_BLUE --> UPDATE_LABELS[Label ì—…ë°ì´íŠ¸<br/>percentages]
    
    UPDATE_LABELS & SKIP --> END[ì™„ë£Œ]
    
    style START fill:#99E9F2,color:#111
    style CALC_PERCENT fill:#FFD93D,color:#111
    style DRAW_RED fill:#FF6B6B,color:#fff
    style DRAW_GREEN fill:#51CF66,color:#fff
    style DRAW_BLUE fill:#4DABF7,color:#fff
```

**ë¸”ë¡ ì½”ë”© (ìƒì„¸)**:
```
ğŸ“ procedure updateChart (color, number)
  parameters: color (text), number (integer)
  
  // 1ë‹¨ê³„: í˜„ì¬ ì¹´ìš´í„° ì½ê¸°
  set redCount to convertToNumber(lblRedCount.Text)
  set greenCount to convertToNumber(lblGreenCount.Text)
  set blueCount to convertToNumber(lblBlueCount.Text)
  
  // 2ë‹¨ê³„: ì´í•© ê³„ì‚°
  set total to redCount + greenCount + blueCount
  
  // 3ë‹¨ê³„: ë¹„ìœ¨ ê³„ì‚°
  if total > 0 then
    set redPercent to round((redCount / total) Ã— 100)
    set greenPercent to round((greenCount / total) Ã— 100)
    set bluePercent to round((blueCount / total) Ã— 100)
    
    // í¼ì„¼íŠ¸ ë¼ë²¨ ì—…ë°ì´íŠ¸
    set lblRedPercent.Text to redPercent + "%"
    set lblGreenPercent.Text to greenPercent + "%"
    set lblBluePercent.Text to bluePercent + "%"
    
    // 4ë‹¨ê³„: Canvas ì´ˆê¸°í™”
    call Canvas1.Clear()
    
    // 5ë‹¨ê³„: ë§‰ëŒ€ ê·¸ë˜í”„ ê·¸ë¦¬ê¸°
    set barWidth to 60
    set maxHeight to 200
    set spacing to 80
    
    // ë¹¨ê°• ë§‰ëŒ€
    set redHeight to (redCount / total) Ã— maxHeight
    call Canvas1.DrawRect(50, 250 - redHeight, barWidth, redHeight)
    set Canvas1.PaintColor to RED
    
    // ì´ˆë¡ ë§‰ëŒ€
    set greenHeight to (greenCount / total) Ã— maxHeight
    call Canvas1.DrawRect(50 + spacing, 250 - greenHeight, barWidth, greenHeight)
    set Canvas1.PaintColor to GREEN
    
    // íŒŒë‘ ë§‰ëŒ€
    set blueHeight to (blueCount / total) Ã— maxHeight
    call Canvas1.DrawRect(50 + spacingÃ—2, 250 - blueHeight, barWidth, blueHeight)
    set Canvas1.PaintColor to BLUE
    
    // 6ë‹¨ê³„: í…ìŠ¤íŠ¸ í‘œì‹œ
    call Canvas1.DrawText("ë¹¨ê°•: " + redCount, 80, 270)
    call Canvas1.DrawText("ì´ˆë¡: " + greenCount, 80 + spacing, 270)
    call Canvas1.DrawText("íŒŒë‘: " + blueCount, 80 + spacingÃ—2, 270)
  else
    set lblRedPercent.Text to "0%"
    set lblGreenPercent.Text to "0%"
    set lblBluePercent.Text to "0%"
  â”œâ”€ call Canvas1.Clear()
  â”œâ”€ call drawPieChart(redPercent, greenPercent, bluePercent)
  â”‚
  â””â”€ // ë§‰ëŒ€ ê·¸ë˜í”„
      â””â”€ call drawBarChart(lblRedCount.Text, lblGreenCount.Text, lblBlueCount.Text)
```

---

## ğŸ“Š Day 2 í‰ê°€ ë° ì„±ì°°

### í•™ìŠµ ì„±ê³¼ ì²´í¬ë¦¬ìŠ¤íŠ¸

**ì„¼ì„œ ë§ˆìŠ¤í„°**:
- [ ] IR ì„¼ì„œ ë””ë°”ìš´ì‹± ì´í•´
- [ ] ì»¬ëŸ¬ ì„¼ì„œ ìœ í´ë¦¬ë“œ ê±°ë¦¬ ì•Œê³ ë¦¬ì¦˜ â­
- [ ] ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ë°©ë²• ìŠµë“

**ëª¨í„° ì œì–´**:
- [ ] DC ëª¨í„° PWM ì œì–´
- [ ] ë¶€ë“œëŸ¬ìš´ ê°€ì†/ê°ì†
- [ ] ì„œë³´ ì •ë°€ ê°ë„ ì œì–´

**í†µí•© ì‹œìŠ¤í…œ**:
- [ ] ìƒíƒœ ë¨¸ì‹  ì„¤ê³„
- [ ] 06ë‹¨ê³„: ìë™ ë¶„ë¥˜ ì™„ì„± â­â­
- [ ] 07ë‹¨ê³„: ë¹„ì°¨ë‹¨ ëª…ë ¹ ì²˜ë¦¬ â­â­
- [ ] 08ë‹¨ê³„: ì´ì¤‘ í†µì‹  + ì¹´ìš´íŒ… â­â­â­

**ì›ê²© ëª¨ë‹ˆí„°ë§**:
- [ ] count_ ë°ì´í„° ì‹¤ì‹œê°„ ì „ì†¡
- [ ] ì•±ì¸ë²¤í„° íŒŒì‹± ë° ì°¨íŠ¸
- [ ] start/stop/init ì œì–´

### ë³µì¡ë„ ë¶„ì„

| ì•Œê³ ë¦¬ì¦˜ | ì‹œê°„ ë³µì¡ë„ | ê³µê°„ ë³µì¡ë„ | ë¹„ê³  |
|---------|-----------|-----------|------|
| ìƒ‰ìƒ íŒë³„ | O(1) | O(1) | ìœ í´ë¦¬ë“œ ê±°ë¦¬ 4ë²ˆ |
| ì‹¤ì‹œê°„ ëª…ë ¹ ì²´í¬ | O(n) | O(n) | n = ëª…ë ¹ ê¸¸ì´ |
| ì œí’ˆ ì¹´ìš´í„° | O(1) | O(1) | ë‹¨ìˆœ ì¦ê°€ |
| í†µí•© ìë™ ë¶„ë¥˜ | O(1) | O(1) | ìƒíƒœ ë¨¸ì‹  |

---

## ğŸ¯ Day 3 ì˜ˆê³ 

### ë‚´ì¼ ë°°ìš¸ ê²ƒ

```mermaid
graph LR
    DAY1[Day 1<br/>ë¡œë´‡íŒ”] --> DAY2[Day 2<br/>ì»¨ë² ì´ì–´]
    DAY2 --> AI[Teachable<br/>Machine]
    AI --> LED[8x8 LED<br/>Matrix]
    LED --> DASHBOARD[ì¬ê³  ê´€ë¦¬<br/>ëŒ€ì‹œë³´ë“œ]
    
    style DAY1 fill:#FFE3E3,color:#111
    style DAY2 fill:#FFF3E0,color:#111
    style AI fill:#FFD93D,color:#111
    style DASHBOARD fill:#51CF66,color:#fff
```

**Day 3 í•µì‹¬**:
- âœ… ì¹´ë©”ë¼ â†’ AI ì¸ì‹ â†’ play_ ëª…ë ¹
- âœ… ë¡œë´‡íŒ” ìë™ ì¤ê¸° â†’ ì»¨ë² ì´ì–´ ë¶„ë¥˜
- âœ… 8x8 LED í™”ì‚´í‘œ í‘œì‹œ
- âœ… ì¬ê³  ê´€ë¦¬ ì•± (ì›í˜•/ë§‰ëŒ€ ì°¨íŠ¸)
- âœ… **ì™„ì „ ìë™í™”**: AI â†’ ë¡œë´‡ â†’ ë¶„ë¥˜ â†’ ì°¨íŠ¸

---

## ğŸ“Š Day 2 ì „ì²´ ì‹œìŠ¤í…œ í†µí•© ì‹œí€€ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨

### ì™„ì „í•œ ìë™í™” ì‹œí€€ìŠ¤

```mermaid
sequenceDiagram
    participant U as ì‚¬ìš©ì
    participant A as ì•±ì¸ë²¤í„°
    participant B as Bluetooth
    participant ARD as Arduino
    participant IR as IR ì„¼ì„œ
    participant COLOR as ì»¬ëŸ¬ ì„¼ì„œ
    participant MOTOR as DC ëª¨í„°
    participant SERVO as ì„œë³´
    participant LED as RGB LED
    
    U->>A: start_ ë²„íŠ¼ í´ë¦­
    A->>B: SendText("start_")
    B->>ARD: start_
    ARD->>MOTOR: analogWrite(120)<br/>ì»¨ë² ì´ì–´ ê°€ë™
    ARD->>B: "OK:START"
    B->>A: ìˆ˜ì‹ 
    A-->>U: ìƒíƒœ: ê°€ë™ ì¤‘
    
    Note over MOTOR: ì»¨ë² ì´ì–´ ë²¨íŠ¸ íšŒì „ ì¤‘...
    
    IR->>ARD: LOW (ì œí’ˆ ê°ì§€!)
    ARD->>ARD: productCount++
    ARD->>MOTOR: analogWrite(0)<br/>ì¼ì‹œ ì •ì§€
    ARD->>B: "PRODUCT_DETECTED"
    B->>A: ìˆ˜ì‹ 
    A-->>U: ğŸ”´ ì œí’ˆ ê°ì§€!
    
    Note over ARD: delay(2000ms)<br/>ì•ˆì •í™” ëŒ€ê¸°
    
    ARD->>MOTOR: analogWrite(120)<br/>ìƒ‰ìƒ ì„¼ì„œë¡œ ì´ë™
    
    loop ìƒ‰ìƒ ê°ì§€ ëŒ€ê¸°
        COLOR->>ARD: getRawData()<br/>rawR, rawG, rawB, rawC
        ARD->>ARD: map(raw â†’ 0~1000)
        ARD->>ARD: sum = r+g+b
        ARD->>ARD: sum < 15?
    end
    
    Note over ARD: ìƒ‰ìƒ ê°ì§€ ì™„ë£Œ!
    
    ARD->>MOTOR: analogWrite(0)<br/>ì •ì§€
    ARD->>ARD: ìƒ‰ìƒ íŒë³„ ì•Œê³ ë¦¬ì¦˜<br/>if r>g && r>b: RED
    
    alt ë¹¨ê°„ìƒ‰
        ARD->>SERVO: attach + write(30Â°)
        ARD->>LED: setPixel(255,0,0)
        ARD->>B: "count_red" + count + "_"
        B->>A: ìˆ˜ì‹ 
        A->>A: extractNumber()<br/>updateChart()
        A-->>U: ë¹¨ê°•: 1ê°œ (33%)
        
    else ì´ˆë¡ìƒ‰
        ARD->>SERVO: attach + write(57Â°)
        ARD->>LED: setPixel(0,255,0)
        ARD->>B: "count_green" + count + "_"
        B->>A: ìˆ˜ì‹ 
        A->>A: updateChart()
        A-->>U: ì´ˆë¡: 1ê°œ (33%)
        
    else íŒŒë€ìƒ‰
        ARD->>SERVO: attach + write(2Â°)
        ARD->>LED: setPixel(0,0,255)
        ARD->>B: "count_blue" + count + "_"
        B->>A: ìˆ˜ì‹ 
        A->>A: updateChart()
        A-->>U: íŒŒë‘: 1ê°œ (33%)
    end
    
    Note over ARD,LED: delay(1500ms)<br/>ë¶„ë¥˜ ì‹œê°„ í™•ë³´
    
    ARD->>SERVO: detach()<br/>ì „ë ¥ ì ˆì•½
    ARD->>MOTOR: analogWrite(120)<br/>ì¬ê°€ë™
    ARD->>B: "count_total" + total + "_"
    B->>A: ìˆ˜ì‹ 
    A->>A: updatePercentage()
    A-->>U: ì´: 3ê°œ
    
    Note over ARD,MOTOR: ë‹¤ìŒ ì œí’ˆ ëŒ€ê¸°...
    
    U->>A: stop_ ë²„íŠ¼ í´ë¦­
    A->>B: SendText("stop_")
    B->>ARD: stop_
    ARD->>MOTOR: analogWrite(0)<br/>ì™„ì „ ì •ì§€
    ARD->>LED: clear()<br/>LED OFF
    ARD->>B: "OK:STOP"
    B->>A: ìˆ˜ì‹ 
    A-->>U: ìƒíƒœ: ì •ì§€
```

### í•µì‹¬ íƒ€ì´ë° ë‹¤ì´ì–´ê·¸ë¨

```mermaid
gantt
    title Day 2 ì œí’ˆ ì²˜ë¦¬ íƒ€ì´ë° (1ê°œ ì œí’ˆ ê¸°ì¤€)
    dateFormat X
    axisFormat %Lms
    
    section IR ê°ì§€
    ì œí’ˆ ê°ì§€          :a1, 0, 100ms
    ë””ë°”ìš´ì‹±           :a2, after a1, 50ms
    
    section ëª¨í„° ì œì–´
    ì»¨ë² ì´ì–´ ì •ì§€      :b1, after a2, 50ms
    ì•ˆì •í™” ëŒ€ê¸°        :b2, after b1, 2000ms
    ìƒ‰ìƒ ì„¼ì„œë¡œ ì´ë™   :b3, after b2, 1000ms
    
    section ìƒ‰ìƒ ë¶„ì„
    ìƒ‰ìƒ ì„¼ì„œ ì½ê¸°     :c1, after b3, 500ms
    ìƒ‰ìƒ íŒë³„          :c2, after c1, 100ms
    
    section ë¶„ë¥˜ ë™ì‘
    ì„œë³´ ê°ë„ ì„¤ì •     :d1, after c2, 500ms
    LED í‘œì‹œ           :d2, after d1, 100ms
    ë¶„ë¥˜ ì‹œê°„ í™•ë³´     :d3, after d2, 1500ms
    
    section Bluetooth ì „ì†¡
    ì¹´ìš´í„° ë°ì´í„° ì „ì†¡ :e1, after d1, 100ms
    ì•± ì°¨íŠ¸ ì—…ë°ì´íŠ¸   :e2, after e1, 200ms
    
    section ì¬ì‹œì‘
    ì„œë³´ ë¶„ë¦¬          :f1, after d3, 50ms
    ì»¨ë² ì´ì–´ ì¬ê°€ë™    :f2, after f1, 50ms
    ë‹¤ìŒ ì œí’ˆ ê°„ê²©     :f3, after f2, 1000ms
```

**ì´ ì²˜ë¦¬ ì‹œê°„**: ì•½ 6-7ì´ˆ/ì œí’ˆ  
**ë³‘ëª© êµ¬ê°„**: ì•ˆì •í™” ëŒ€ê¸° (2ì´ˆ) + ë¶„ë¥˜ ì‹œê°„ (1.5ì´ˆ)  
**ìµœì í™” í¬ì¸íŠ¸**: ëŒ€ê¸° ì‹œê°„ ë‹¨ì¶• (í˜„ì¬: 3.5ì´ˆ â†’ ëª©í‘œ: 2ì´ˆ)

### ë³µì¡ë„ ë¶„ì„ (Day 2 ì „ì²´)

| ì•Œê³ ë¦¬ì¦˜ | ì‹œê°„ ë³µì¡ë„ | ê³µê°„ ë³µì¡ë„ | ë¹„ê³  |
|---------|-----------|-----------|------|
| IR ì„¼ì„œ ê°ì§€ | O(1) | O(1) | ë””ì§€í„¸ ì½ê¸° |
| ìƒ‰ìƒ ì„¼ì„œ ì½ê¸° | O(n) | O(1) | n = ì„¼ì„œ ì•ˆì •í™” ì‹œê°„ |
| ìƒ‰ìƒ íŒë³„ (ìµœëŒ€ê°’) | O(1) | O(1) | 3íšŒ ë¹„êµ ê³ ì • |
| ìƒ‰ìƒ íŒë³„ (ìœ í´ë¦¬ë“œ) | O(k) | O(1) | k = ê¸°ì¤€ ìƒ‰ìƒ ìˆ˜ |
| PWM ì œì–´ | O(1) | O(1) | ë‹¨ì¼ analogWrite |
| ì„œë³´ ì œì–´ | O(1) | O(1) | ë‹¨ì¼ write |
| millis() íƒ€ì´ë° | O(n) | O(n) | n = íƒ€ì´ë¨¸ ê°œìˆ˜ |
| Bluetooth íŒŒì‹± | O(m) | O(m) | m = ëª…ë ¹ ê¸¸ì´ |
| ì¹´ìš´í„° ì—…ë°ì´íŠ¸ | O(1) | O(1) | 4ê°œ ê³ ì • ì¹´ìš´í„° |
| ì°¨íŠ¸ ê·¸ë¦¬ê¸° | O(1) | O(1) | ë§‰ëŒ€ 3ê°œ ê³ ì • |
| **ì „ì²´ ì‹œìŠ¤í…œ** | **O(n+m+k)** | **O(n+m)** | **ì‹¤ì‹œê°„ ì œì•½ ì¶©ì¡±** |

---

**Day 2 ì™„ë£Œ!** ğŸ‰

**"ì„¼ì„œì™€ ì•Œê³ ë¦¬ì¦˜ì„ ì •ë³µí–ˆìŠµë‹ˆë‹¤. ë‚´ì¼ì€ AIë¡œ ì™„ì „ ìë™í™”!"** ğŸš€

---

**Last Updated**: 2026-01-25  
**Version**: 3.1 (ì•Œê³ ë¦¬ì¦˜ í”Œë¡œìš°ì°¨íŠ¸ ìƒì„¸í™”)  
**ì´ í•™ìŠµ ì‹œê°„**: 8ì‹œê°„  
**ì½”ë“œ ë¼ì¸**: ~2,188ì¤„ (01~08ë‹¨ê³„)  
**í•µì‹¬ ì•Œê³ ë¦¬ì¦˜**: 9ê°€ì§€ (IR ê°ì§€, ìƒ‰ìƒ íŒë³„ 2ì¢…, PWM ì œì–´, ì„œë³´ ì œì–´, millis íƒ€ì´ë°, Bluetooth íŒŒì‹±, ì¹´ìš´í„°, ì°¨íŠ¸)
