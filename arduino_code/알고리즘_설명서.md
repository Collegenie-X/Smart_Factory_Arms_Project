# 스마트 팩토리 핵심 알고리즘 상세 설명서

## 📚 목차
1. [EEPROM 위치 저장/복구 알고리즘 (Day 1)](#1-eeprom-위치-저장복구-알고리즘-day-1)
2. [자동 재생 및 무한 반복 알고리즘 (Day 1)](#2-자동-재생-및-무한-반복-알고리즘-day-1)
3. [Bluetooth 명령 버퍼링 알고리즘 (Day 1)](#3-bluetooth-명령-버퍼링-알고리즘-day-1)
4. [컬러 센서 RGB 분석 알고리즘 (Day 2)](#4-컬러-센서-rgb-분석-알고리즘-day-2)
5. [실시간 명령 체크 알고리즘 (Day 2)](#5-실시간-명령-체크-알고리즘-day-2)
6. [제품 카운터 및 전송 알고리즘 (Day 2)](#6-제품-카운터-및-전송-알고리즘-day-2)
7. [통합 자동 분류 알고리즘 (Day 2)](#7-통합-자동-분류-알고리즘-day-2)

---

## 1. EEPROM 위치 저장/복구 알고리즘 (Day 1)

### 📖 개념
아두이노의 EEPROM에 로봇팔 위치를 저장하여 전원이 꺼져도 데이터를 유지하는 알고리즘입니다.  
**핵심 기법**: 비휘발성 메모리 활용, 바이트 단위 저장

### 🎯 목적
- 전원 꺼져도 위치 데이터 유지
- 최대 12개 위치 저장 가능
- 빠른 읽기/쓰기 (수 밀리초)
- 메모리 효율적 관리

### 🗂️ 메모리 맵
```
주소     내용
━━━━━━━━━━━━━━━━━━━━
0-3      저장된 위치 개수 (4바이트, int)
4-7      위치 #1 (베이스, 팔1, 팔2, 그립)
8-11     위치 #2
12-15    위치 #3
...
48-51    위치 #12
━━━━━━━━━━━━━━━━━━━━
총 사용: 52바이트
```

### 💻 저장 알고리즘
```cpp
// 04_eeprom_automation.ino
void saveCurrentPosition() {
  // 1. 최대 개수 확인 (Early return)
  if (savedCount >= MAX_POSITIONS) {
    Serial.println("[오류] 최대 12개까지 저장 가능");
    return;
  }
  
  // 2. 서보 분리 (EEPROM 쓰기 중 타이머 충돌 방지)
  for (int i = 0; i < 4; i++) {
    servo[i].detach();
  }
  
  // 3. 기준 주소 계산 (4바이트 건너뛰기)
  int baseAddr = 4 + (savedCount * 4);
  
  // 4. 4개 각도 저장
  EEPROM.write(baseAddr + 0, angles[0]);  // 베이스
  EEPROM.write(baseAddr + 1, angles[1]);  // 팔1
  EEPROM.write(baseAddr + 2, angles[2]);  // 팔2
  EEPROM.write(baseAddr + 3, angles[3]);  // 그립
  
  // 5. 카운트 증가 및 저장
  savedCount++;
  EEPROM.write(0, savedCount);
  
  // 6. 서보 재부착
  for (int i = 0; i < 4; i++) {
    servo[i].attach(pin[i]);
    servo[i].write(angles[i]);
  }
  
  Serial.print("[OK #");
  Serial.print(savedCount);
  Serial.println("]");
}
```

### 💻 복구 알고리즘
```cpp
void loadAllPositions() {
  // 1. 저장된 개수 읽기
  savedCount = EEPROM.read(0);
  
  // 2. 범위 검증
  if (savedCount > MAX_POSITIONS) {
    savedCount = 0;
    return;
  }
  
  // 3. 모든 위치 읽기
  for (int i = 0; i < savedCount; i++) {
    int baseAddr = 4 + (i * 4);
    
    savedAngles[i][0] = EEPROM.read(baseAddr + 0);
    savedAngles[i][1] = EEPROM.read(baseAddr + 1);
    savedAngles[i][2] = EEPROM.read(baseAddr + 2);
    savedAngles[i][3] = EEPROM.read(baseAddr + 3);
  }
  
  Serial.print("복원된 위치: ");
  Serial.print(savedCount);
  Serial.println("개");
}
```

### 📊 성능 분석
- **시간 복잡도**: O(1) - 상수 시간 (4바이트 저장)
- **공간 복잡도**: O(n), n = 저장된 위치 개수 (최대 12개)
- **쓰기 시간**: ~3.3ms (1바이트당)
- **읽기 시간**: ~100μs (매우 빠름)
- **수명**: 100,000회 쓰기 보장

### 💡 최적화 팁
- 서보 detach/attach로 타이머 충돌 방지
- 외부 전원 사용으로 전력 부족 방지
- 범위 검증으로 데이터 손상 방지

---

## 2. 자동 재생 및 무한 반복 알고리즘 (Day 1)

### 📖 개념
EEPROM에 저장된 위치들을 순차적으로 이동하며, 1회 재생 또는 무한 반복이 가능한 알고리즘입니다.  
**핵심 기법**: 상태 플래그, 비차단 중지 처리

### 🎯 목적
- 저장된 동작 자동 재생
- 무한 반복 모드 지원
- 언제든지 즉시 중지 가능
- 반복 횟수 카운팅

### 💻 구현 코드
```cpp
// 04_eeprom_automation.ino
void playAutoMode() {
  if (savedCount == 0) {
    Serial.println("[오류] 저장된 위치 없음");
    return;
  }
  
  Serial.println("========================================");
  Serial.println("  자동 반복 모드 시작");
  Serial.println("========================================");
  Serial.print("저장된 위치 수: ");
  Serial.println(savedCount);
  Serial.println("'stop' 명령으로 중지");
  Serial.println("========================================");
  
  autoMode = true;
  repeatCount = 0;
  
  // 무한 반복 루프
  while (autoMode) {
    repeatCount++;
    
    Serial.println("========================================");
    Serial.print("  반복 #");
    Serial.print(repeatCount);
    Serial.println(" 실행 중...");
    Serial.println("========================================");
    
    // 저장된 모든 위치로 순차 이동
    for (int i = 0; i < savedCount; i++) {
      Serial.print("→ 위치 #");
      Serial.print(i + 1);
      Serial.println(" 이동");
      
      // 각 축 이동
      for (int axis = 0; axis < 4; axis++) {
        int targetAngle = savedAngles[i][axis];
        
        // 부드러운 이동 (1도씩)
        while (angles[axis] != targetAngle) {
          if (angles[axis] < targetAngle) {
            angles[axis]++;
          } else {
            angles[axis]--;
          }
          servo[axis].write(angles[axis]);
          delay(15);
          
          // 매 스텝마다 stop 명령 체크
          if (Serial.available()) {
            String cmd = Serial.readStringUntil('\n');
            cmd.trim();
            if (cmd == "stop") {
              autoMode = false;
              goto exitLoop;  // 즉시 종료
            }
          }
        }
      }
      
      delay(500);  // 위치 도달 후 대기
    }
    
    delay(1000);  // 반복 간격
  }
  
  exitLoop:
  Serial.println("========================================");
  Serial.println("  자동 반복 모드 중지");
  Serial.println("========================================");
  Serial.print("총 반복 횟수: ");
  Serial.println(repeatCount);
  Serial.println("========================================");
}
```

### 🔄 실행 흐름
```
사용자 'auto' 명령 입력
    ↓
autoMode = true 설정
    ↓
┌─────────────────┐
│ while (autoMode)│
└────┬────────────┘
     │
     ├→ 위치 #1 이동 (stop 체크)
     ├→ 위치 #2 이동 (stop 체크)
     ├→ 위치 #3 이동 (stop 체크)
     │  ...
     ├→ 반복 횟수 증가
     └→ 다시 처음부터 (stop 명령까지)
         ↓
    사용자 'stop' 입력
         ↓
    autoMode = false
         ↓
    반복 종료
```

### 📊 성능 분석
- **시간 복잡도**: O(n × m), n = 반복 횟수, m = 저장된 위치 개수
- **공간 복잡도**: O(1)
- **중지 반응 시간**: 15ms 이내 (매 1도 이동마다 체크)

### 💡 최적화 팁
- `goto` 문으로 다중 루프 즉시 탈출
- 매 스텝마다 Serial 체크로 즉각 반응
- 반복 간격 조정으로 속도 제어

---

## 3. Bluetooth 명령 버퍼링 알고리즘 (Day 1)

### 📖 개념
Bluetooth로 수신되는 문자를 버퍼에 저장하고 종료 문자(`_`)를 만나면 명령을 처리하는 알고리즘입니다.  
**핵심 기법**: 문자 단위 버퍼링, 구분자 기반 파싱

### 🎯 목적
- 문자 단위로 들어오는 Bluetooth 데이터 처리
- 완전한 명령이 도착할 때까지 대기
- Serial과 Bluetooth 구분 처리
- 디버깅용 상세 로그 출력

### 💻 구현 코드
```cpp
// 05_bluetooth_eeprom_automation.ino
String btCommandBuffer = "";  // Bluetooth 명령 버퍼

void loop() {
  // Bluetooth 데이터 수신 및 버퍼링
  while (BT.available()) {
    char c = BT.read();
    
    // 디버깅: 수신 문자 출력
    Serial.print("[BT 수신] '");
    Serial.print(c);
    Serial.print("' (ASCII: ");
    Serial.print((int)c);
    Serial.println(")");
    
    // 종료 문자 '_' 확인
    if (c == '_') {
      Serial.print("[명령 종료 문자: '_'] 명령어 버퍼: \"");
      Serial.print(btCommandBuffer);
      Serial.print("\" (길이: ");
      Serial.print(btCommandBuffer.length());
      Serial.println(")");
      
      // 명령 처리
      processCommand(btCommandBuffer, "Bluetooth");
      
      // 버퍼 초기화
      btCommandBuffer = "";
    } else {
      // 버퍼에 문자 추가
      btCommandBuffer += c;
      
      Serial.print("[버퍼 추가] 현재: \"");
      Serial.print(btCommandBuffer);
      Serial.print("\" (");
      Serial.print(btCommandBuffer.length());
      Serial.println("자)");
    }
  }
  
  // Serial 데이터 처리 (Enter 키 사용)
  if (Serial.available()) {
    String serialCmd = Serial.readStringUntil('\n');
    serialCmd.trim();
    processCommand(serialCmd, "Serial");
  }
}

void processCommand(String cmd, String source) {
  Serial.println("========================================");
  Serial.print("[명령 처리 시작] from ");
  Serial.println(source);
  Serial.print("받은 명령어: \"");
  Serial.print(cmd);
  Serial.println("\"");
  
  // ASCII 코드 출력 (디버깅용)
  Serial.print("ASCII 코드: ");
  for (int i = 0; i < cmd.length(); i++) {
    Serial.print((int)cmd[i]);
    Serial.print(" ");
  }
  Serial.println();
  
  // 명령 처리
  if (cmd == "save") {
    Serial.println("[인식] save 명령 실행");
    saveCurrentPosition();
  } else if (cmd == "play") {
    Serial.println("[인식] play 명령 실행");
    playOnce();
  } else if (cmd == "auto") {
    Serial.println("[인식] auto 명령 실행");
    playAutoMode();
  } else if (cmd == "stop") {
    Serial.println("[인식] stop 명령 실행");
    autoMode = false;
  } else {
    Serial.print("[오류] 알 수 없는 명령: ");
    Serial.println(cmd);
  }
  
  Serial.println("========================================");
}
```

### 🔍 버퍼링 과정
```
Bluetooth 수신: 's' → 버퍼: "s"
Bluetooth 수신: 'a' → 버퍼: "sa"
Bluetooth 수신: 'v' → 버퍼: "sav"
Bluetooth 수신: 'e' → 버퍼: "save"
Bluetooth 수신: '_' → 명령 처리 "save"
                    ↓
                버퍼 초기화 ""
```

### 📡 통신 프로토콜 비교
| 특징 | Serial | Bluetooth |
|------|--------|-----------|
| 종료 문자 | `\n` (Enter) | `_` |
| 명령 예시 | `save` + Enter | `save_` |
| 읽기 방식 | `readStringUntil('\n')` | 문자 단위 버퍼링 |
| 디버깅 | Serial Monitor | Serial Monitor에 출력 |

### 📊 성능 분석
- **시간 복잡도**: O(n), n = 명령 길이
- **공간 복잡도**: O(n), n = 버퍼 크기
- **처리 시간**: 실시간 (문자당 1ms 이내)

### 💡 최적화 팁
- 버퍼 크기 제한으로 메모리 보호
- 타임아웃 설정으로 불완전 명령 처리
- 디버그 출력으로 문제 추적 용이

---


## 4. 컬러 센서 RGB 분석 알고리즘 (Day 2)

### 📖 개념
TCS34725 I2C 컬러 센서로 측정한 RGB 값을 분석하여 주요 색상을 판별하는 알고리즘입니다.  
**핵심 기법**: 비율 기반 판별, 임계값 검증

### 🎯 목적
- 빨강, 초록, 파랑 주요 색상 판별
- 노이즈 제거 (낮은 값 필터링)
- 혼합 색상 처리 (노랑, 흰색)
- 빠른 판단 (실시간 처리)

### 💻 구현 코드
```cpp
// 02_color_sensor_test.ino
String identifyColor(uint16_t r, uint16_t g, uint16_t b) {
  // 1. 유효성 검증 (Early return)
  if (r + g + b < MIN_COLOR_SUM) {
    return "Unknown";  // 너무 어두움
  }
  
  // 2. 주요 색상 판별
  // 특정 색이 다른 색보다 COLOR_DOMINANCE(1.3)배 이상 높으면 해당 색상
  if (r > g * COLOR_DOMINANCE && r > b * COLOR_DOMINANCE) {
    return "Red";     // 빨강 우세
  } else if (g > r * COLOR_DOMINANCE && g > b * COLOR_DOMINANCE) {
    return "Green";   // 초록 우세
  } else if (b > r * COLOR_DOMINANCE && b > g * COLOR_DOMINANCE) {
    return "Blue";    // 파랑 우세
  }
  
  // 3. 혼합 색상 판별
  if (r > 50 && g > 50 && b < 30) {
    return "Yellow";  // 빨강 + 초록 = 노랑
  }
  if (r > 50 && g > 50 && b > 50) {
    return "White";   // 모두 높음 = 흰색
  }
  if (r < 20 && g < 20 && b < 20) {
    return "Black";   // 모두 낮음 = 검정
  }
  
  return "Unknown";   // 판별 불가
}
```

### 📐 수학적 원리
```
주요 색상 판별 조건:

빨간색:
  R > G × 1.3  AND  R > B × 1.3

초록색:
  G > R × 1.3  AND  G > B × 1.3

파란색:
  B > R × 1.3  AND  B > G × 1.3

예시:
  RGB(15, 5, 5)
  → 15 > 5 × 1.3 (6.5) ✓
  → 15 > 5 × 1.3 (6.5) ✓
  → "Red" 판별
```

### 🎨 색상 판별 테이블
| RGB 값 | R | G | B | 판별 결과 |
|--------|---|---|---|-----------|
| 빨간색 | 15 | 5 | 5 | Red |
| 초록색 | 3 | 11 | 4 | Green |
| 파란색 | 4 | 5 | 13 | Blue |
| 노란색 | 12 | 10 | 3 | Yellow |
| 흰색 | 50 | 50 | 50 | White |
| 검정색 | 2 | 2 | 2 | Black |

### 💻 실제 측정 예시
```cpp
// 06_integrated_conveyor_system.ino
String identifyColor() {
  // TCS34725 센서에서 RGB 값 읽기
  uint16_t r, g, b, c;
  colorSensor.getRawData(&r, &g, &b, &c);
  
  // Raw 값을 0~255 범위로 정규화
  uint16_t normalizedR = map(r, 0, 65535, 0, 255);
  uint16_t normalizedG = map(g, 0, 65535, 0, 255);
  uint16_t normalizedB = map(b, 0, 65535, 0, 255);
  
  // 색상 판별
  String color = classifyColor(normalizedR, normalizedG, normalizedB);
  
  // 디버깅 출력
  Serial.println("--- 색상 분석 결과 ---");
  Serial.print("Raw -> R: ");
  Serial.print(r);
  Serial.print(", G: ");
  Serial.print(g);
  Serial.print(", B: ");
  Serial.println(b);
  
  Serial.print("RGB -> R: ");
  Serial.print(normalizedR);
  Serial.print(", G: ");
  Serial.print(normalizedG);
  Serial.print(", B: ");
  Serial.println(normalizedB);
  
  Serial.print("판별 색상: ");
  Serial.println(color);
  Serial.println("---------------------");
  
  return color;
}
```

### 📊 성능 분석
- **시간 복잡도**: O(1) - 상수 시간 판별
- **공간 복잡도**: O(1)
- **측정 시간**: ~50ms (센서 통합 시간 포함)
- **정확도**: 90% 이상 (적절한 조명 환경에서)

### 💡 최적화 팁
- `SENSOR_GAIN` 조정: 어두운 환경 → 높은 GAIN (16X)
- `COLOR_DOMINANCE` 조정: 1.3~1.5 범위 (높을수록 엄격)
- `MIN_COLOR_SUM` 조정: 노이즈 제거 임계값
- 조명 일정하게 유지

---

## 5. 실시간 명령 체크 알고리즘 (Day 2)

### 📖 개념
delay 중에도 Serial/Bluetooth 명령을 지속적으로 체크하여 즉각 반응하는 비차단 알고리즘입니다.  
**핵심 기법**: Polling 방식, 비차단 지연

### 🎯 목적
- delay 중에도 stop 명령 즉시 반응
- 제품 처리 중 중지 가능
- 50ms 이내 반응 시간
- CPU 효율적 처리

### 💻 구현 코드
```cpp
// 07_serial_controlled_system.ino
void delayWithSerialCheck(unsigned long duration) {
  unsigned long startTime = millis();
  
  // duration 시간 동안 반복
  while (millis() - startTime < duration) {
    // Serial 명령 체크
    if (checkSerialCommand()) {
      processCommand();
    }
    
    // 50ms 대기 (CPU 부하 감소)
    delay(50);
    
    // stop 명령 시 즉시 종료
    if (!isRunning) {
      break;
    }
  }
}

bool checkSerialCommand() {
  if (!Serial.available()) {
    return false;
  }
  
  char c = Serial.read();
  
  // 종료 문자 '_' 확인
  if (c == '_') {
    commandBuffer.trim();
    return true;
  } else {
    commandBuffer += c;
    return false;
  }
}

void processCommand() {
  Serial.print("[명령 수신] ");
  Serial.println(commandBuffer);
  
  if (commandBuffer == "start") {
    isRunning = true;
    Serial.println("자동화 시작");
  } else if (commandBuffer == "stop") {
    isRunning = false;
    Serial.println("자동화 중지");
  }
  
  commandBuffer = "";  // 버퍼 초기화
}
```

### 🔄 실행 흐름
```
일반 delay (문제):
  delay(2000);
  → 2초 동안 아무것도 못함
  → stop 명령 입력해도 2초 후에야 반응

비차단 delay (해결책):
  delayWithSerialCheck(2000);
  → 50ms마다 명령 체크
  → stop 명령 시 즉시 종료
  → 최대 50ms 지연만 발생
```

### 📊 타이밍 다이어그램
```
시간 →
0ms    50ms   100ms  150ms  200ms
|------|------|------|------|
  체크    체크    체크    체크
  ↓      ↓      ↓      ↓
 명령    명령    stop!  즉시
 없음    없음    감지   종료
                 ↓
              break
```

### 💻 이중 통신 확장 (08단계)
```cpp
// 08_dual_comm_system.ino
void delayWithCommandCheck(unsigned long duration) {
  unsigned long startTime = millis();
  
  while (millis() - startTime < duration) {
    // Serial 체크
    if (checkSerialCommand()) {
      processCommand(serialBuffer, "Serial");
    }
    
    // Bluetooth 체크
    if (checkBluetoothCommand()) {
      processCommand(btBuffer, "Bluetooth");
    }
    
    delay(50);
    
    if (!isRunning) break;
  }
}

bool checkBluetoothCommand() {
  if (!BT.available()) return false;
  
  char c = BT.read();
  if (c == '_') {
    btBuffer.trim();
    return true;
  } else {
    btBuffer += c;
  }
  return false;
}
```

### 📊 성능 분석
- **시간 복잡도**: O(n), n = duration / 50ms
- **반응 시간**: 최대 50ms
- **CPU 사용률**: 매우 낮음 (대부분 delay 상태)
- **정확도**: 100% (모든 명령 감지)

### 💡 최적화 팁
- 체크 간격 조정: 20ms → 더 빠른 반응, 높은 CPU 사용
- 체크 간격 조정: 100ms → 느린 반응, 낮은 CPU 사용
- 50ms가 최적 균형점

---

## 6. 제품 카운터 및 전송 알고리즘 (Day 2)

### 📖 개념
색상별 제품 개수를 카운팅하고 Bluetooth로 실시간 전송하는 알고리즘입니다.  
**핵심 기법**: 카운터 배열, 포맷 문자열 생성

### 🎯 목적
- 빨강/초록/파랑 색상별 개수 추적
- 실시간 데이터 전송
- 카운터 초기화 기능
- 디버깅용 로그 출력

### 💻 구현 코드
```cpp
// 08_dual_comm_system.ino
int redCount = 0;
int greenCount = 0;
int blueCount = 0;

void sendColorCounterToBluetooth(String color) {
  String message = "";
  
  // 1. 색상별 카운터 증가 및 메시지 생성
  if (color == "Red") {
    redCount++;
    message = "red" + String(redCount) + "_";
  } else if (color == "Green") {
    greenCount++;
    message = "green" + String(greenCount) + "_";
  } else if (color == "Blue") {
    blueCount++;
    message = "blue" + String(blueCount) + "_";
  } else {
    return;  // Unknown 색상은 무시
  }
  
  // 2. Serial과 Bluetooth 동시 전송
  Serial.print("[카운터 전송] ");
  Serial.println(message);
  BT.print(message);
}

void initializeCounters() {
  Serial.println("========================================");
  Serial.println("  카운터 초기화 실행");
  Serial.println("========================================");
  
  // 현재 카운터 출력
  Serial.print("빨간색: ");
  Serial.print(redCount);
  Serial.println(" → 0");
  
  Serial.print("초록색: ");
  Serial.print(greenCount);
  Serial.println(" → 0");
  
  Serial.print("파란색: ");
  Serial.print(blueCount);
  Serial.println(" → 0");
  
  // 카운터 초기화
  redCount = 0;
  greenCount = 0;
  blueCount = 0;
  
  // 시스템 자동 중지
  isRunning = false;
  
  Serial.println("카운터 초기화 완료 + 시스템 중지");
  Serial.println("========================================");
  
  // Bluetooth로 확인 메시지 전송
  BT.println("init_ok_");
}
```

### 📡 전송 프로토콜
| 이벤트 | 전송 메시지 | 설명 |
|--------|------------|------|
| 빨간색 #1 감지 | `red1_` | 빨간색 1번째 제품 |
| 빨간색 #2 감지 | `red2_` | 빨간색 2번째 제품 |
| 초록색 #1 감지 | `green1_` | 초록색 1번째 제품 |
| 파란색 #1 감지 | `blue1_` | 파란색 1번째 제품 |
| 카운터 초기화 | `init_ok_` | 초기화 완료 확인 |

### 🔄 동작 시나리오
```
[시작]
red: 0, green: 0, blue: 0

[제품 #1 감지]
색상: Red
redCount: 0 → 1
전송: "red1_"

[제품 #2 감지]
색상: Green
greenCount: 0 → 1
전송: "green1_"

[제품 #3 감지]
색상: Red
redCount: 1 → 2
전송: "red2_"

[init 명령 수신]
red: 2 → 0
green: 1 → 0
blue: 0 → 0
전송: "init_ok_"
시스템 중지
```

### 💻 앱 인벤터 연동
```
앱 인벤터에서 수신 처리:

when BluetoothClient.TextReceived
  if received contains "red"
    → 빨간색 카운터 표시 업데이트
    → 예: "red5_" → Label.Red.Text = "5"
  
  if received contains "green"
    → 초록색 카운터 표시 업데이트
  
  if received contains "blue"
    → 파란색 카운터 표시 업데이트
  
  if received contains "init_ok"
    → 모든 카운터 0으로 초기화
    → 상태 메시지 "초기화 완료" 표시
```

### 📊 성능 분석
- **시간 복잡도**: O(1) - 상수 시간
- **공간 복잡도**: O(1) - 3개 변수만 사용
- **전송 시간**: ~10ms (Bluetooth)
- **신뢰도**: 100% (유실 없음)

### 💡 최적화 팁
- 전송 전 버퍼 확인으로 유실 방지
- 타임스탬프 추가로 순서 보장
- 누적 합계도 전송하여 검증

---

## 7. 통합 자동 분류 알고리즘 (Day 2)

### 📖 개념
물체 감지부터 색상 분류까지 전체 프로세스를 자동으로 수행하는 통합 알고리즘입니다.  
**핵심 기법**: 순차 처리, 함수 모듈화

### 🎯 목적
- 완전 자동화 분류 시스템
- 모든 센서/액추에이터 통합
- 안정적인 타이밍 제어
- 명확한 상태 피드백

### 💻 구현 코드
```cpp
// 06_integrated_conveyor_system.ino
void loop() {
  // 자동화 모드가 아니면 대기
  if (!isRunning) {
    return;
  }
  
  // 1. 물체 감지 대기
  if (isProductDetected()) {
    processDetectedProduct();
  }
  
  delay(100);
}

void processDetectedProduct() {
  productCount++;
  
  Serial.println("========================================");
  Serial.print("제품 #");
  Serial.print(productCount);
  Serial.println(" 감지됨!");
  Serial.println("========================================");
  
  // 2. 컨베이어 정지
  stopConveyor();
  
  // 3. 알림음
  playDetectionSound();
  
  // 4. 색상 센서 위치까지 이동
  Serial.println("색상 센서 위치로 이동 중...");
  delayWithCommandCheck(DELAY_IR_DETECT);
  
  // 5. 색상 분석
  String color = identifyColor();
  printColorData(color);
  
  // 6. 분류 방향 설정
  setSortingDirection(color);
  
  // 7. LED 색상 표시
  displayColorOnLED(color);
  
  // 8. 대기
  delayWithCommandCheck(DELAY_COLOR_DETECT);
  
  // 9. 카운터 전송 (08단계)
  sendColorCounterToBluetooth(color);
  
  // 10. 제품 처리 완료
  Serial.println("제품 처리 완료");
  Serial.println();
  
  // 11. 컨베이어 재가동
  startConveyor();
  
  // 12. 다음 제품 대기
  delayWithCommandCheck(DELAY_NEXT_PRODUCT);
}

bool isProductDetected() {
  int irValue = analogRead(PIN_IR_SENSOR);
  return (irValue < DETECTION_THRESHOLD);
}

void setSortingDirection(String color) {
  int angle = SERVO_ANGLE_CENTER;
  
  if (color == "Red") {
    angle = SERVO_ANGLE_RED;       // 25°
  } else if (color == "Green") {
    angle = SERVO_ANGLE_GREEN;     // 90°
  } else if (color == "Blue") {
    angle = SERVO_ANGLE_BLUE;      // 155°
  }
  
  servo.write(angle);
  Serial.print("서보 각도: ");
  Serial.print(angle);
  Serial.println("°");
  
  delay(500);
  servo.detach();  // 전력 절약 및 떨림 방지
}
```

### 🔄 전체 처리 흐름
```
[IDLE 상태]
  ↓
컨베이어 작동 중...
  ↓
IR 센서 감지!
  ↓
┌─────────────────────────┐
│ 제품 처리 프로세스       │
├─────────────────────────┤
│ 1. 컨베이어 정지         │
│ 2. 부저 알림 (삐삐)      │
│ 3. 색상 센서까지 이동    │
│    (2초 대기)            │
│ 4. RGB 색상 분석         │
│ 5. 서보 분류 방향 설정   │
│ 6. RGB LED 색상 표시     │
│ 7. 1.5초 대기            │
│ 8. 카운터 전송 (08단계)  │
│ 9. 컨베이어 재가동       │
│ 10. 1초 대기             │
└─────────────────────────┘
  ↓
다음 제품 대기...
  ↓
[IDLE 상태]
```

### 📊 타이밍 다이어그램
```
시간축 →
0s    2s    3.5s   4.5s
|-----|-----|------|
감지  이동  분석   재가동
  ↓    ↓    ↓      ↓
부저  대기  LED   다음
알림       표시   제품
```

### 📊 성능 분석
- **처리 시간**: ~4.5초/제품
- **처리량**: ~13개/분
- **정확도**: 90% 이상
- **안정성**: 매우 높음 (모듈화된 구조)

### 💡 최적화 팁
- 타이밍 조정: `DELAY_IR_DETECT`, `DELAY_COLOR_DETECT`
- 속도 향상: 각 delay 값을 줄임
- 정확도 향상: 센서 위치 조정, 조명 개선
- 안정성 향상: 에러 처리 추가

---

---

## 📊 알고리즘 복잡도 요약

| 알고리즘 | 시간 복잡도 | 공간 복잡도 | 실행 시간 | 비고 |
|----------|-------------|-------------|----------|------|
| EEPROM 저장 | O(1) | O(1) | ~13ms | 4바이트 쓰기 |
| EEPROM 복구 | O(n) | O(n) | ~1ms | n = 저장된 위치 개수 |
| 자동 재생 | O(n×m) | O(1) | 가변 | n = 반복, m = 위치 수 |
| Bluetooth 버퍼링 | O(n) | O(n) | 실시간 | n = 명령 길이 |
| 색상 판별 | O(1) | O(1) | ~50ms | 센서 통합 시간 포함 |
| 실시간 명령 체크 | O(n) | O(1) | 50ms 반응 | n = duration / 50ms |
| 제품 카운터 | O(1) | O(1) | ~10ms | Bluetooth 전송 |
| 통합 분류 | O(1) | O(1) | ~4.5초 | 제품당 처리 시간 |

---

## 🎓 학습 권장 순서

### 초급 (Day 1)
1. **EEPROM 저장/복구 알고리즘** (알고리즘 #1)
   - 04_eeprom_automation 프로그램
   - 비휘발성 메모리 이해
   - 간단한 데이터 구조

2. **자동 재생 알고리즘** (알고리즘 #2)
   - 04_eeprom_automation 프로그램
   - 루프와 플래그 활용
   - 즉시 중지 처리

3. **Bluetooth 버퍼링 알고리즘** (알고리즘 #3)
   - 05_bluetooth_eeprom_automation 프로그램
   - 문자 단위 처리
   - 구분자 기반 파싱

### 중급 (Day 2)
4. **색상 판별 알고리즘** (알고리즘 #4)
   - 02_color_sensor_test 프로그램
   - 비율 기반 판별
   - 임계값 활용

5. **실시간 명령 체크 알고리즘** (알고리즘 #5)
   - 07_serial_controlled_system 프로그램
   - 비차단 처리
   - Polling 방식

6. **제품 카운터 알고리즘** (알고리즘 #6)
   - 08_dual_comm_system 프로그램
   - 데이터 전송
   - 이중 통신

### 고급 (Day 2)
7. **통합 자동 분류 알고리즘** (알고리즘 #7)
   - 06_integrated_conveyor_system 프로그램
   - 전체 프로세스 통합
   - 모듈화 설계

---

## 💡 핵심 개념 정리

### 1. Early Return 패턴
```cpp
// 조건을 먼저 확인하고 조기 종료
if (savedCount >= MAX_POSITIONS) {
  return;  // 더 이상 진행 안함
}
// 정상 처리 계속...
```

### 2. 비차단 처리 (Non-blocking)
```cpp
// 나쁜 예
delay(2000);  // 2초 동안 멈춤

// 좋은 예
delayWithSerialCheck(2000);  // 50ms마다 체크
```

### 3. 상태 플래그
```cpp
bool autoMode = false;  // 상태 저장
bool isRunning = false;  // 실행 여부

// 상태에 따라 동작 변경
if (autoMode) {
  // 자동 모드 처리
}
```

### 4. 모듈화
```cpp
// 기능별로 함수 분리
void processDetectedProduct() {
  stopConveyor();
  playDetectionSound();
  identifyColor();
  setSortingDirection();
  displayColorOnLED();
  startConveyor();
}
```

---

## 📝 실전 활용 팁

### 디버깅
1. **Serial 출력 활용**
   - 모든 주요 단계에 로그 추가
   - 변수 값 확인
   - ASCII 코드 출력

2. **단계별 테스트**
   - 모듈별로 분리 테스트
   - 통합 전 개별 검증
   - 문제 발생 시 해당 모듈만 수정

3. **디버그 모드**
   - `#define DEBUG_ENABLED true`
   - 필요 시 상세 로그 활성화

### 최적화
1. **메모리 절약**
   - String 대신 char 배열
   - 불필요한 변수 제거
   - 상수는 `#define` 사용

2. **속도 향상**
   - delay 시간 최소화
   - 불필요한 Serial 출력 제거
   - 센서 GAIN 조정

3. **안정성 향상**
   - 범위 검증 추가
   - 에러 처리 강화
   - 타임아웃 설정

---

**작성**: Smart Factory Education Team  
**최종 업데이트**: 2026-01-25  
**버전**: 2.0 (실제 프로젝트 구조 반영)
