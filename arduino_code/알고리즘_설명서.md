# 스마트 팩토리 핵심 알고리즘 상세 설명서

## 📚 목차
1. [동기화 이동 알고리즘](#1-동기화-이동-알고리즘)
2. [블루투스 프로토콜 파싱 알고리즘](#2-블루투스-프로토콜-파싱-알고리즘)
3. [EEPROM 저장/복구 알고리즘](#3-eeprom-저장복구-알고리즘)
4. [컬러 센서 RGB 분석 알고리즘](#4-컬러-센서-rgb-분석-알고리즘)
5. [상태 머신 알고리즘](#5-상태-머신-알고리즘)
6. [예외 처리 알고리즘](#6-예외-처리-알고리즘)

---

## 1. 동기화 이동 알고리즘

### 📖 개념
4축 로봇팔의 모든 서보가 동시에 목표 위치에 도달하도록 하는 알고리즘입니다.  
**핵심 기법**: 선형 보간 (Linear Interpolation)

### 🎯 목적
- 부드러운 움직임
- 동시 도착 (시간 동기화)
- 부하 분산

### 📐 수학적 원리
```
현재 위치: C = [c₀, c₁, c₂, c₃]
목표 위치: T = [t₀, t₁, t₂, t₃]

각 스텝에서의 위치 (진행률 p):
P(p) = C + (T - C) × p

여기서 p ∈ [0, 1], 0은 시작, 1은 완료
```

### 💻 구현 코드
```cpp
bool synchronizedMove(const RobotPosition& target) {
  // 1. 각 축별 이동 거리 계산
  int distance[4];
  for (int i = 0; i < 4; i++) {
    distance[i] = abs(target[i] - current[i]);
  }
  
  // 2. 최대 이동 거리 찾기
  int maxDistance = max(distance);
  
  // 3. 스텝 수 계산
  int steps = maxDistance / STEP_SIZE;
  
  // 4. 동기화된 이동
  for (int step = 1; step <= steps; step++) {
    float progress = (float)step / steps;  // 진행률
    
    for (int axis = 0; axis < 4; axis++) {
      // 선형 보간
      int newAngle = current[axis] + 
                     (target[axis] - current[axis]) * progress;
      servos[axis].write(newAngle);
    }
    
    delay(STEP_DELAY);
  }
  
  return true;
}
```

### 📊 성능 분석
- **시간 복잡도**: O(n), n = 스텝 수
- **공간 복잡도**: O(1)
- **실행 시간**: maxDistance × STEP_DELAY (예: 90도 이동 = 1350ms)

### 💡 최적화 팁
- `STEP_SIZE` 증가 → 빠르지만 덜 부드러움
- `STEP_DELAY` 감소 → 빠르지만 떨림 가능

---

## 2. 블루투스 프로토콜 파싱 알고리즘

### 📖 개념
블루투스로 수신한 문자열 명령을 구조화된 데이터로 변환하는 알고리즘입니다.

### 🎯 명령 프로토콜
| 명령 | 형식 | 파라미터 | 예시 |
|------|------|----------|------|
| 홈 | `H` | 없음 | `H` |
| 수동 이동 | `M` | base,shoulder,elbow,gripper | `M90,90,90,0` |
| 저장 | `S` | slot (1-3) | `S1` |
| AI | `A` | color zone | `A RED 1` |

### 💻 구현 코드
```cpp
bool parseCommand(Command& cmd) {
  // 1. 버퍼 확인 (Early return)
  if (!Serial.available()) {
    return false;
  }
  
  // 2. 명령 타입 읽기
  char cmdType = Serial.read();
  cmd.type = cmdType;
  
  // 3. 명령 타입별 처리
  switch (cmdType) {
    case 'H':  // 홈
      cmd.valid = true;
      break;
    
    case 'M': {  // 수동 이동
      // 파라미터 읽기 "90,90,90,0"
      String paramStr = "";
      while (Serial.available()) {
        char c = Serial.read();
        if (c == '\n') break;
        paramStr += c;
      }
      
      // 쉼표로 분리
      if (parseParams(paramStr, cmd.params)) {
        cmd.valid = true;
      }
      break;
    }
    
    // ... 기타 명령
  }
  
  return cmd.valid;
}
```

### 🔍 파싱 단계
```
입력: "M90,90,90,0\n"
  ↓
1. 명령 타입 추출: 'M'
  ↓
2. 파라미터 문자열 추출: "90,90,90,0"
  ↓
3. 쉼표로 분리: ["90", "90", "90", "0"]
  ↓
4. 정수 변환: [90, 90, 90, 0]
  ↓
5. 검증: 범위 확인 (0-180)
  ↓
출력: Command{type='M', params=[90,90,90,0], valid=true}
```

### 📊 성능 분석
- **시간 복잡도**: O(m), m = 파라미터 개수
- **공간 복잡도**: O(n), n = 문자열 길이

---

## 3. EEPROM 저장/복구 알고리즘

### 📖 개념
비휘발성 메모리에 로봇 위치를 안전하게 저장하는 알고리즘입니다.  
**핵심 기법**: 체크섬 (Checksum) 검증

### 🗂️ 메모리 맵
```
주소     내용
━━━━━━━━━━━━━━━━━━━━
0-3      슬롯 1 (base, shoulder, elbow, gripper)
4-7      슬롯 2
8-11     슬롯 3
12-14    체크섬 (슬롯별)
━━━━━━━━━━━━━━━━━━━━
```

### 💻 저장 알고리즘
```cpp
bool savePosition(uint8_t slot, const RobotPosition& pos) {
  // 1. 슬롯 검증 (Early return)
  if (slot < 1 || slot > 3) return false;
  
  // 2. 주소 계산
  uint16_t addr = (slot - 1) * 4;
  
  // 3. 데이터 쓰기
  EEPROM.write(addr + 0, pos.base);
  EEPROM.write(addr + 1, pos.shoulder);
  EEPROM.write(addr + 2, pos.elbow);
  EEPROM.write(addr + 3, pos.gripper);
  
  // 4. 체크섬 계산 및 저장
  uint8_t checksum = (pos.base + pos.shoulder + 
                      pos.elbow + pos.gripper) % 256;
  EEPROM.write(12 + slot - 1, checksum);
  
  return true;
}
```

### 💻 복구 알고리즘
```cpp
bool loadPosition(uint8_t slot, RobotPosition& pos) {
  // 1. 슬롯 검증
  if (slot < 1 || slot > 3) return false;
  
  // 2. 주소 계산
  uint16_t addr = (slot - 1) * 4;
  
  // 3. 체크섬 읽기
  uint8_t storedChecksum = EEPROM.read(12 + slot - 1);
  
  // 4. 데이터 읽기
  pos.base = EEPROM.read(addr + 0);
  pos.shoulder = EEPROM.read(addr + 1);
  pos.elbow = EEPROM.read(addr + 2);
  pos.gripper = EEPROM.read(addr + 3);
  
  // 5. 체크섬 검증
  uint8_t calcChecksum = (pos.base + pos.shoulder + 
                          pos.elbow + pos.gripper) % 256;
  
  if (storedChecksum != calcChecksum) {
    return false;  // 데이터 손상
  }
  
  return true;
}
```

### 🔒 체크섬 원리
```
체크섬 = (데이터 합) MOD 256

예시:
  base = 90, shoulder = 90, elbow = 90, gripper = 0
  합 = 90 + 90 + 90 + 0 = 270
  체크섬 = 270 % 256 = 14

복구 시:
  저장된 체크섬 = 14
  계산된 체크섬 = (읽은 데이터 합) % 256
  일치 여부 확인
```

---

## 4. 컬러 센서 RGB 분석 알고리즘

### 📖 개념
TCS3200 센서로 측정한 RGB 값을 기준 색상과 비교하여 판단하는 알고리즘입니다.  
**핵심 기법**: 유클리드 거리 (Euclidean Distance)

### 📐 수학적 원리
```
3차원 색공간에서 두 점 사이의 거리:

d = √[(r₁ - r₂)² + (g₁ - g₂)² + (b₁ - b₂)²]

가장 가까운 색상이 판단 결과
```

### 💻 구현 코드
```cpp
Color detectColor(const RGBColor& rgb) {
  // 1. 각 기준 색상과의 거리 계산
  float distRed = euclideanDistance(rgb, refRed);
  float distBlue = euclideanDistance(rgb, refBlue);
  float distYellow = euclideanDistance(rgb, refYellow);
  
  // 2. 최소 거리 찾기
  float minDist = min(distRed, min(distBlue, distYellow));
  Color result = COLOR_UNKNOWN;
  
  if (minDist == distRed) result = COLOR_RED;
  else if (minDist == distBlue) result = COLOR_BLUE;
  else if (minDist == distYellow) result = COLOR_YELLOW;
  
  // 3. 임계값 확인
  if (minDist > THRESHOLD) {
    result = COLOR_UNKNOWN;  // 너무 멀면 인식 불가
  }
  
  return result;
}

float euclideanDistance(const RGBColor& c1, const RGBColor& c2) {
  int dr = c1.r - c2.r;
  int dg = c1.g - c2.g;
  int db = c1.b - c2.b;
  return sqrt(dr*dr + dg*dg + db*db);
}
```

### 📊 색공간 시각화
```
      B (파랑)
      ↑
      |
      |     ● 측정값
      |    /|
      |   / |
      |  /  |
      | /   |
      |/    |
━━━━━━━━━━━━━━━━━→ R (빨강)
     /
    /
   ↓
  G (초록)
```

### 🎨 중앙값 필터 (노이즈 제거)
```cpp
Color readColorFiltered() {
  // 5회 측정
  Color samples[5];
  for (int i = 0; i < 5; i++) {
    samples[i] = detectColor(readRGB());
    delay(50);
  }
  
  // 최빈값 선택
  int countRed = 0, countBlue = 0, countYellow = 0;
  for (int i = 0; i < 5; i++) {
    if (samples[i] == COLOR_RED) countRed++;
    else if (samples[i] == COLOR_BLUE) countBlue++;
    else if (samples[i] == COLOR_YELLOW) countYellow++;
  }
  
  // 최대 카운트 반환
  if (countRed >= countBlue && countRed >= countYellow)
    return COLOR_RED;
  else if (countBlue >= countYellow)
    return COLOR_BLUE;
  else
    return COLOR_YELLOW;
}
```

---

## 5. 상태 머신 알고리즘

### 📖 개념
시스템의 동작을 명확한 상태와 전이 조건으로 관리하는 알고리즘입니다.

### 🔄 상태 다이어그램 (시나리오 A)
```
    ┌──────┐
    │ IDLE │ ◀─────────────────────┐
    └──┬───┘                       │
       │ AI 명령 수신               │
       ↓                           │
  ┌──────────┐                    │
  │ SCANNING │                    │
  └────┬─────┘                    │
       │ 신뢰도 > 80%              │
       ↓                           │
  ┌─────────┐                     │
  │ PICKING │                     │
  └────┬────┘                     │
       │ 집기 성공                 │
       ↓                           │
┌──────────────┐                  │
│ TRANSPORTING │                  │
└───────┬──────┘                  │
        │ 컨베이어 투입            │
        ↓                          │
  ┌──────────┐                    │
  │ DETECTING│                    │
  └────┬─────┘                    │
       │ IR 감지                   │
       ↓                           │
  ┌──────────┐                    │
  │ VERIFYING│                    │
  └────┬─────┘                    │
       │ 색상 일치                 │
       ↓                           │
  ┌─────────┐                     │
  │ SORTING │─────────────────────┘
  └─────────┘
```

### 💻 구현 코드
```cpp
void StateMachine::update() {
  switch (currentState) {
    case STATE_IDLE:
      // AI 명령 대기 (외부에서 전이)
      break;
    
    case STATE_PICKING:
      if (robotArm->pickSequence(zone)) {
        transitionTo(STATE_TRANSPORTING);
      } else {
        retryCount++;
        if (retryCount >= MAX_RETRY) {
          transitionTo(STATE_ERROR);
        }
      }
      break;
    
    case STATE_VERIFYING:
      Color sensorColor = colorSensor->read();
      if (sensorColor == aiColor) {
        transitionTo(STATE_SORTING);
      } else {
        transitionTo(STATE_ERROR);
      }
      break;
    
    // ... 기타 상태
  }
}
```

### 🔀 전이 조건표
| 현재 상태 | 조건 | 다음 상태 |
|-----------|------|-----------|
| IDLE | AI 명령 수신 | SCANNING |
| SCANNING | 신뢰도 ≥ 80% | PICKING |
| PICKING | 집기 성공 | TRANSPORTING |
| PICKING | 3회 실패 | ERROR |
| VERIFYING | 색상 일치 | SORTING |
| VERIFYING | 색상 불일치 | ERROR |
| SORTING | 완료 | IDLE |
| ERROR | 복구 | IDLE |

---

## 6. 예외 처리 알고리즘

### 📖 개념
시스템 오류를 감지하고 자동으로 복구하는 알고리즘입니다.  
**핵심 기법**: 지수 백오프 (Exponential Backoff)

### 📈 지수 백오프 원리
```
재시도 지연 시간 = 기본 지연 × 2^(재시도 횟수)

1회: 100ms × 2⁰ = 100ms
2회: 100ms × 2¹ = 200ms
3회: 100ms × 2² = 400ms
4회: 100ms × 2³ = 800ms
```

### 💻 구현 코드
```cpp
ProcessResult handleSensorTimeout() {
  retryCount++;
  
  // 최대 재시도 확인
  if (retryCount >= MAX_RETRY_COUNT) {
    retryCount = 0;
    return RESULT_FAIL;
  }
  
  // 지수 백오프 지연
  unsigned long delayTime = 100 * (1 << retryCount);
  delay(delayTime);
  
  return RESULT_RETRY;
}
```

### 🛠️ 예외 유형별 처리
| 예외 유형 | 처리 방법 | 결과 |
|-----------|-----------|------|
| HARDWARE_FAULT | 비상 정지 | HALTED |
| SENSOR_TIMEOUT | 재시도 (지수 백오프) | RETRY |
| COMMUNICATION_LOST | 재연결 | RECOVERED |
| POSITION_ERROR | 홈 캘리브레이션 | RECOVERED |
| UNKNOWN | 안전 모드 | SAFE |

### 🔄 복구 플로우
```
오류 발생
  ↓
예외 유형 식별
  ↓
┌─────────────┐
│ 재시도 가능?│
└──┬────┬─────┘
   │Yes │No
   ↓    ↓
 재시도  복구 불가
   ↓      ↓
 성공?  사용자 개입
   ↓
 복구 완료
```

---

## 📊 알고리즘 복잡도 요약

| 알고리즘 | 시간 복잡도 | 공간 복잡도 | 비고 |
|----------|-------------|-------------|------|
| 동기화 이동 | O(n) | O(1) | n = 스텝 수 |
| 프로토콜 파싱 | O(m) | O(n) | m = 파라미터, n = 문자열 |
| EEPROM 저장 | O(1) | O(1) | 상수 시간 |
| EEPROM 복구 | O(1) | O(1) | 체크섬 포함 |
| 색상 판단 | O(k) | O(1) | k = 기준 색상 수 |
| 상태 머신 | O(1) | O(1) | switch 분기 |
| 예외 처리 | O(r) | O(1) | r = 재시도 횟수 |

---

**작성**: Smart Factory Education Team  
**날짜**: 2026-01-22  
**버전**: 1.0
