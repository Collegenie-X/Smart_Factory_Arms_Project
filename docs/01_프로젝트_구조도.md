# 스마트 팩토리 & 로봇 팔 프로젝트 전체 구조도
> **알고리즘 중심 아키텍처 - 대학생 28시간 교육용**

## 📌 핵심 설계 철학

- **알고리즘 우선**: 코드 작성 전 플로우차트 설계
- **계층적 구조**: 입력 → 처리 → 출력 명확히 분리
- **상태 머신**: 복잡한 시스템을 상태로 관리
- **피지컬 모니터링**: 로컬(LED+부저) + 원격(앱) 이중 피드백

---

## 1. 전체 시스템 알고리즘 아키텍처

```mermaid
graph TB
    subgraph 입력_계층[입력 계층 - 센싱]
        A1[스마트폰 카메라<br/>앱인벤터]
        A2[아두이노 센서<br/>IR/컬러/초음파]
        A3[사용자 입력<br/>앱 UI 버튼]
    end
    
    subgraph AI_계층[AI 계층 - 추론]
        B1[Teachable Machine<br/>이미지 분류]
        B2[신뢰도 검증<br/>>80%]
        B3[명령 매핑<br/>빨강→1, 파랑→2]
    end
    
    subgraph 통신_계층[통신 계층 - 프로토콜]
        C1[앱인벤터<br/>BluetoothClient]
        C2[HC-06 블루투스<br/>9600 baud]
        C3[아두이노 Serial<br/>명령 파싱]
    end
    
    subgraph 제어_계층[제어 계층 - 상태 머신]
        D1[상태 관리<br/>IDLE/PICKING/SORTING]
        D2[알고리즘 실행<br/>집기/분류/이동]
        D3[타이밍 제어<br/>millis 기반]
    end
    
    subgraph 하드웨어_계층[하드웨어 계층 - 구동]
        E1[로봇팔 4축<br/>동기화 이동]
        E2[컨베이어 벨트<br/>DC 모터 PWM]
        E3[게이트 서보<br/>각도 제어]
    end
    
    subgraph 모니터링_계층[모니터링 계층 - 피드백]
        F1[LED Matrix<br/>상태 아이콘]
        F2[피에조 부저<br/>청각 피드백]
        F3[시리얼 모니터<br/>디버깅 로그]
        F4[앱 대시보드<br/>통계 차트]
    end
    
    A1 -->|촬영| B1
    A2 -->|센서값| D1
    A3 -->|버튼| C1
    
    B1 --> B2
    B2 --> B3
    B3 --> C1
    
    C1 <-->|블루투스| C2
    C2 <-->|시리얼| C3
    
    C3 --> D1
    D1 --> D2
    D2 --> D3
    
    D2 --> E1
    D2 --> E2
    D2 --> E3
    
    D1 --> F1
    D1 --> F2
    D1 --> F3
    D1 --> F4
    
    style AI_계층 fill:#FFD93D,color:#111
    style 제어_계층 fill:#6BCB77,color:#fff
    style 모니터링_계층 fill:#C59DFF,color:#fff
```

---

## 2. 핵심 알고리즘 구조

### 2.1 상태 머신 알고리즘

```mermaid
stateDiagram-v2
    [*] --> IDLE: 시스템 시작
    
    IDLE --> SCANNING: AI 명령 수신
    SCANNING --> IDLE: 신뢰도 < 80%
    SCANNING --> PICKING: 신뢰도 >= 80%
    
    PICKING --> TRANSPORTING: 집기 성공
    PICKING --> ERROR: 3회 실패
    
    TRANSPORTING --> DETECTING: 3초 경과
    
    DETECTING --> VERIFYING: IR 감지
    DETECTING --> DETECTING: 물체 없음
    
    VERIFYING --> SORTING: 색상 일치
    VERIFYING --> ERROR: 색상 불일치
    
    SORTING --> IDLE: 분류 완료
    
    ERROR --> IDLE: 오류 처리 완료
    
    IDLE --> [*]: 시스템 종료
```

**핵심 특징**:
- 명확한 상태 정의 (7개 상태)
- 조건에 따른 상태 전이
- 오류 상태로 안전하게 복귀

### 2.2 제어 알고리즘 계층 구조

```mermaid
graph TD
    subgraph 상위_알고리즘[상위 레벨 - 시나리오]
        L3_1[AI 기반 입고]
        L3_2[센서 기반 분류]
        L3_3[티칭 기반 생산]
    end
    
    subgraph 중위_알고리즘[중위 레벨 - 시퀀스]
        L2_1[집기 시퀀스<br/>5단계]
        L2_2[이동 시퀀스<br/>동기화]
        L2_3[분류 시퀀스<br/>게이트 제어]
    end
    
    subgraph 하위_알고리즘[하위 레벨 - 기본 동작]
        L1_1[서보 제어<br/>PWM]
        L1_2[센서 읽기<br/>필터링]
        L1_3[통신<br/>파싱]
    end
    
    L3_1 --> L2_1
    L3_2 --> L2_2
    L3_3 --> L2_3
    
    L2_1 --> L1_1
    L2_1 --> L1_2
    L2_2 --> L1_1
    L2_3 --> L1_1
    L2_3 --> L1_3
    
    style 상위_알고리즘 fill:#FF6B6B,color:#fff
    style 중위_알고리즘 fill:#FFD93D,color:#111
    style 하위_알고리즘 fill:#6BCB77,color:#fff
```

---

## 3. 데이터 흐름 알고리즘

```mermaid
flowchart TB
    START[시작] --> INIT[초기화<br/>홈 포지션]
    
    INIT --> CAPTURE[1. 데이터 수집<br/>카메라 촬영]
    CAPTURE --> CLASSIFY[2. AI 추론<br/>TM 분류]
    
    CLASSIFY --> CONF{신뢰도<br/>>80%?}
    CONF -->|No| RETRY[재촬영]
    RETRY --> CAPTURE
    CONF -->|Yes| MAP[3. 명령 매핑<br/>색상→구역]
    
    MAP --> SEND[4. 프로토콜 생성<br/>JSON]
    SEND --> BT[5. 블루투스 전송<br/>1바이트]
    
    BT --> PARSE[6. 명령 파싱<br/>switch문]
    PARSE --> STATE[7. 상태 전이<br/>IDLE→PICKING]
    
    STATE --> EXEC[8. 알고리즘 실행<br/>집기 시퀀스]
    EXEC --> SENSOR[9. 센서 검증<br/>IR+컬러]
    
    SENSOR --> VERIFY{검증<br/>통과?}
    VERIFY -->|No| ERROR[오류 처리]
    ERROR --> INIT
    VERIFY -->|Yes| MONITOR[10. 모니터링<br/>LED+앱 업데이트]
    
    MONITOR --> STATS[11. 통계 수집<br/>카운트++]
    STATS --> COMPLETE[완료]
    COMPLETE --> INIT
    
    style CLASSIFY fill:#FFD93D,color:#111
    style STATE fill:#6BCB77,color:#fff
    style ERROR fill:#FF6B6B,color:#fff
```

---

## 4. 하드웨어 통합 구조 (알고리즘 관점)

```mermaid
graph TB
    subgraph 스마트폰_알고리즘[스마트폰 - 앱인벤터]
        SP1[카메라 입력<br/>Image Picker]
        SP2[AI 추론 알고리즘<br/>TMIC Extension]
        SP3[통신 프로토콜<br/>BluetoothClient]
        SP4[UI 업데이트 알고리즘<br/>Label, Chart]
    end
    
    subgraph 아두이노_알고리즘[아두이노 - 상태 머신]
        AR1[명령 파싱 알고리즘<br/>Serial.read]
        AR2[센서 필터링 알고리즘<br/>이동 평균]
        AR3[모터 제어 알고리즘<br/>동기화 이동]
        AR4[타이밍 알고리즘<br/>millis 비차단]
    end
    
    subgraph 하드웨어[하드웨어 - 액추에이터]
        HW1[로봇팔 4축<br/>서보 x4]
        HW2[컨베이어<br/>DC 모터]
        HW3[게이트<br/>서보 x1]
        HW4[LED Matrix<br/>8x8]
        HW5[피에조 부저]
    end
    
    SP1 --> SP2
    SP2 --> SP3
    SP4 <--> SP3
    
    SP3 <-->|블루투스<br/>명령/응답| AR1
    
    AR1 --> AR3
    AR2 --> AR3
    AR3 --> AR4
    
    AR3 --> HW1
    AR3 --> HW2
    AR3 --> HW3
    AR4 --> HW4
    AR4 --> HW5
    
    style 스마트폰_알고리즘 fill:#4CAF50,color:#fff
    style 아두이노_알고리즘 fill:#2196F3,color:#fff
    style 하드웨어 fill:#FF9800,color:#fff
```

---

## 5. 알고리즘 기술 스택 계층

```mermaid
graph TB
    subgraph Layer5[응용 계층 - 시나리오 알고리즘]
        L5_1[시나리오 A<br/>AI 입고]
        L5_2[시나리오 B<br/>센서 분류]
        L5_3[시나리오 C<br/>티칭 생산]
    end
    
    subgraph Layer4[비즈니스 로직 - 상태 머신]
        L4_1[상태 정의<br/>7개 상태]
        L4_2[전이 조건<br/>if/switch]
        L4_3[타이밍 제어<br/>millis]
    end
    
    subgraph Layer3[제어 알고리즘 - 시퀀스]
        L3_1[집기 알고리즘<br/>5단계]
        L3_2[이동 알고리즘<br/>동기화]
        L3_3[분류 알고리즘<br/>게이트]
    end
    
    subgraph Layer2[기본 알고리즘 - 처리]
        L2_1[센서 필터<br/>이동 평균]
        L2_2[PWM 제어<br/>analogWrite]
        L2_3[프로토콜 파싱<br/>문자열 처리]
    end
    
    subgraph Layer1[하드웨어 인터페이스]
        L1_1[디지털 I/O<br/>pinMode]
        L1_2[시리얼 통신<br/>Serial]
        L1_3[타이머<br/>millis]
    end
    
    L5_1 --> L4_1
    L5_2 --> L4_2
    L5_3 --> L4_3
    
    L4_1 --> L3_1
    L4_2 --> L3_2
    L4_3 --> L3_3
    
    L3_1 --> L2_1
    L3_2 --> L2_2
    L3_3 --> L2_3
    
    L2_1 --> L1_1
    L2_2 --> L1_2
    L2_3 --> L1_3
    
    style Layer5 fill:#FF6B6B,color:#fff
    style Layer4 fill:#FFD93D,color:#111
    style Layer3 fill:#6BCB77,color:#fff
    style Layer2 fill:#95E1D3,color:#111
    style Layer1 fill:#A8DADC,color:#111
```

**학습 경로**:
1. **하위 → 상위 순서** (기초부터)
2. **Day 1**: Layer 1-2 (기본 알고리즘)
3. **Day 2**: Layer 3-4 (제어 + 상태 머신)
4. **Day 3**: Layer 5 (통합 시나리오)

---

## 6. 통신 프로토콜 알고리즘

```mermaid
sequenceDiagram
    participant 앱 as 앱인벤터
    participant AI as Teachable Machine
    participant BT as 블루투스
    participant ARD as 아두이노 (상태 머신)
    participant HW as 하드웨어
    
    Note over 앱,HW: 초기화 단계
    앱->>BT: 연결 요청
    BT->>ARD: 핸드셰이크
    ARD->>HW: 홈 포지션
    ARD-->>앱: "READY"
    
    Note over 앱,HW: AI 인식 단계
    앱->>앱: 사진 촬영
    앱->>AI: 이미지 전송
    AI-->>앱: {"class":"빨강", "conf":0.95}
    
    앱->>앱: if (conf > 0.8)
    앱->>BT: {"cmd":"AI", "color":"RED", "zone":1}
    
    Note over 앱,HW: 상태 전이 단계
    BT->>ARD: JSON 파싱
    ARD->>ARD: state = PICKING
    ARD->>HW: 집기 시퀀스 실행
    
    HW-->>ARD: 동작 완료
    ARD->>ARD: state = DETECTING
    
    Note over 앱,HW: 검증 단계
    ARD->>ARD: IR 센서 확인
    ARD->>ARD: 컬러 센서 측정
    ARD->>ARD: if (sensorColor == aiColor)
    ARD->>ARD: state = SORTING
    
    Note over 앱,HW: 피드백 단계
    ARD->>HW: LED Matrix 표시
    ARD->>HW: 부저 소리
    ARD->>BT: {"status":"OK", "count":5}
    BT->>앱: 통계 업데이트
```

**프로토콜 설계 원칙**:
- ✅ **JSON 포맷** (구조화)
- ✅ **명확한 키값** (`cmd`, `color`, `zone`)
- ✅ **오류 코드** (`ERROR_PICK`, `ERROR_COLOR`)
- ✅ **타임아웃** (5초 응답 없으면 재시도)

---

## 7. 모니터링 시스템 알고리즘

```mermaid
graph TB
    subgraph 상태_변경[상태 변경 이벤트]
        E1[state = PICKING]
        E2[state = SORTING]
        E3[ERROR]
    end
    
    subgraph 로컬_모니터링[로컬 모니터링 알고리즘]
        L1[LED Matrix<br/>아이콘 표시]
        L2[피에조 부저<br/>주파수 출력]
        L3[시리얼 모니터<br/>로그 출력]
    end
    
    subgraph 원격_모니터링[원격 모니터링 알고리즘]
        R1[JSON 생성<br/>통계 포함]
        R2[블루투스 전송<br/>30초 간격]
        R3[앱 UI 업데이트<br/>Label, Chart]
    end
    
    E1 --> L1
    E1 --> L2
    E1 --> L3
    E2 --> L1
    E2 --> L2
    E2 --> L3
    E3 --> L1
    E3 --> L2
    E3 --> L3
    
    E1 --> R1
    E2 --> R1
    E3 --> R1
    
    R1 --> R2
    R2 --> R3
    
    style 로컬_모니터링 fill:#FFD93D,color:#111
    style 원격_모니터링 fill:#6BCB77,color:#fff
```

### LED Matrix 아이콘 매핑

| 상태 | 아이콘 | 부저 주파수 |
|------|--------|------------|
| `IDLE` | 🏠 홈 | 없음 |
| `SCANNING` | 📷 카메라 | 1000 Hz |
| `PICKING` | 🤖 집기 | 1500 Hz |
| `SORTING` | ✅ 성공 | 2000 Hz |
| `ERROR` | ❌ 오류 | 500 Hz |

---

## 8. 오류 처리 알고리즘

```mermaid
flowchart TD
    ERROR[오류 발생] --> CLASSIFY{오류<br/>유형?}
    
    CLASSIFY -->|HARDWARE| HW_ERR[하드웨어 오류]
    CLASSIFY -->|SENSOR| SENS_ERR[센서 오류]
    CLASSIFY -->|COMM| COMM_ERR[통신 오류]
    CLASSIFY -->|LOGIC| LOGIC_ERR[로직 오류]
    
    HW_ERR --> HW_ACT[긴급 정지<br/>모든 모터 정지]
    SENS_ERR --> SENS_ACT[센서 재시도<br/>3회 시도]
    COMM_ERR --> COMM_ACT[재연결<br/>블루투스]
    LOGIC_ERR --> LOGIC_ACT[상태 리셋<br/>IDLE 복귀]
    
    HW_ACT --> LOG[로그 기록<br/>EEPROM]
    SENS_ACT --> LOG
    COMM_ACT --> LOG
    LOGIC_ACT --> LOG
    
    LOG --> NOTIFY[앱 알림<br/>오류 메시지]
    NOTIFY --> SAFE[안전 모드<br/>홈 포지션]
    
    SAFE --> WAIT[사용자 확인<br/>대기]
    WAIT --> RESUME[재시작]
    
    style ERROR fill:#FF6B6B,color:#fff
    style SAFE fill:#FFD93D,color:#111
```

**오류 처리 원칙**:
1. **즉각 정지**: 하드웨어 오류 시 모든 동작 중단
2. **3회 재시도**: 센서/통신 오류는 재시도
3. **로그 기록**: 모든 오류를 EEPROM에 저장
4. **사용자 알림**: 앱으로 오류 메시지 전송
5. **안전 복귀**: 홈 포지션으로 안전하게 복귀

---

## 9. 성능 최적화 알고리즘

### 9.1 타이밍 최적화

```mermaid
graph LR
    subgraph 차단_방식[❌ 차단 방식 (BAD)]
        B1[pickObject] --> B2[delay 3000ms]
        B2 --> B3[checkSensor]
        B3 --> B4[delay 2000ms]
    end
    
    subgraph 비차단_방식[✅ 비차단 방식 (GOOD)]
        G1[state = PICKING<br/>startTime = millis]
        G1 --> G2[루프 실행<br/>센서 읽기 가능]
        G2 --> G3{millis - start<br/>>= 3000?}
        G3 -->|No| G2
        G3 -->|Yes| G4[state = CHECKING]
    end
    
    B4 -.총 5초 블로킹.-> SLOW[느림😢]
    G4 -.비차단 실행.-> FAST[빠름😊]
    
    style 차단_방식 fill:#FF6B6B,color:#fff
    style 비차단_방식 fill:#6BCB77,color:#fff
```

### 9.2 센서 노이즈 필터링

```
알고리즘: Moving_Average_Filter
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
입력: newSample (새 센서 값)

데이터 구조:
  buffer[10] = {0}
  index = 0
  sum = 0

프로세스:
  1. 버퍼 업데이트
     sum -= buffer[index]
     buffer[index] = newSample
     sum += newSample
     index = (index + 1) % 10
  
  2. 평균 계산
     average = sum / 10
  
  3. RETURN average

시간 복잡도: O(1) - 효율적!
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 10. 알고리즘 복잡도 분석

| 알고리즘 | 시간 복잡도 | 공간 복잡도 | 병목 지점 |
|---------|-----------|-----------|----------|
| **상태 머신** | O(1) | O(1) | 없음 (효율적) |
| **동기화 이동** | O(n) | O(1) | n = 스텝 수 (최대 180) |
| **센서 필터링** | O(1) | O(w) | w = 윈도우 크기 (10) |
| **AI 추론** | O(?) | O(?) | 앱인벤터 내부 (측정 불가) |
| **프로토콜 파싱** | O(n) | O(1) | n = JSON 길이 (작음) |

**최적화 우선순위**:
1. ✅ **상태 머신**: 이미 효율적
2. ⚠️ **동기화 이동**: stepSize 크게 (2-3도) → 속도 향상
3. ✅ **센서 필터링**: 이동 평균 O(1) 사용
4. ⚠️ **AI 추론**: 가벼운 모델 사용 (TM 50x50 이미지)

---

## 11. 시스템 동작 시퀀스 (알고리즘 관점)

```mermaid
sequenceDiagram
    participant U as 사용자
    participant APP as 앱
    participant SM as 상태 머신
    participant ALG as 알고리즘 엔진
    participant HW as 하드웨어
    
    Note over U,HW: 초기화
    U->>APP: 앱 실행
    APP->>SM: state = IDLE
    SM->>HW: goHome()
    
    Note over U,HW: AI 인식
    U->>APP: 촬영 버튼
    APP->>APP: AI 추론
    APP->>SM: {"cmd":"AI", "color":"RED"}
    
    Note over U,HW: 상태 전이
    SM->>SM: state = SCANNING
    SM->>SM: validate(aiResult)
    SM->>SM: state = PICKING
    
    Note over U,HW: 알고리즘 실행
    SM->>ALG: pickSequence()
    ALG->>HW: synchronizedMove(angles)
    HW-->>ALG: 완료
    ALG-->>SM: SUCCESS
    
    Note over U,HW: 검증
    SM->>SM: state = DETECTING
    SM->>HW: readIR()
    SM->>SM: state = VERIFYING
    SM->>HW: readColor()
    
    Note over U,HW: 분류
    SM->>SM: if (match) state = SORTING
    SM->>ALG: sortByGate(color)
    ALG->>HW: gate.write(angle)
    
    Note over U,HW: 피드백
    SM->>HW: displayIcon(DONE)
    SM->>APP: {"status":"OK", "count":5}
    APP->>U: 화면 업데이트
    
    SM->>SM: state = IDLE
```

---

## 12. 파일 구조 (알고리즘 중심)

```
Smart_Factory_Arms_Project/
│
├── 📂 algorithms/                     # 알고리즘 문서
│   ├── flowcharts/                    # 플로우차트 (Mermaid)
│   │   ├── state_machine.md
│   │   ├── pick_sequence.md
│   │   └── error_handling.md
│   │
│   ├── pseudocode/                    # 의사코드
│   │   ├── control_algorithms.md
│   │   ├── sensor_algorithms.md
│   │   └── communication_protocols.md
│   │
│   └── performance/                   # 성능 분석
│       ├── complexity_analysis.md
│       └── timing_measurements.md
│
├── 📂 arduino_code/                   # 예제 코드
│   ├── day1_robot_control/
│   │   ├── servo_control.ino         # 기본 제어
│   │   └── bluetooth_comm.ino        # 통신
│   │
│   ├── day2_conveyor_sensor/
│   │   ├── sensor_filtering.cpp      # 센서 필터링
│   │   └── motor_controller.cpp      # 모터 제어
│   │
│   └── day3_scenarios/
│       ├── state_machine.cpp         # 상태 머신
│       └── scenario_a.ino            # 통합 시나리오
│
└── 📂 app_inventor/                   # 앱인벤터 파일
    ├── control_app.aia               # 제어 앱
    └── monitoring_dashboard.aia      # 모니터링 앱
```

---

## 13. 알고리즘 학습 로드맵 (28시간)

```mermaid
gantt
    title 알고리즘 학습 일정
    dateFormat  HH:mm
    axisFormat %H:%M
    
    section Day 1
    기본 알고리즘 (PWM, 서보)        :d1_1, 09:00, 2h
    제어 알고리즘 (4축 동기화)        :d1_2, 11:00, 2h
    통신 알고리즘 (프로토콜)         :d1_3, 13:00, 2h
    저장 알고리즘 (EEPROM)           :d1_4, 15:00, 1.5h
    
    section Day 2
    센서 알고리즘 (필터링)           :d2_1, 09:00, 2h
    AI 알고리즘 (데이터+학습)        :d2_2, 11:00, 3h
    통합 알고리즘 (로봇팔+AI)        :d2_3, 14:00, 2.5h
    
    section Day 3
    상태 머신 설계                  :d3_1, 09:00, 2h
    시나리오 알고리즘 구현           :d3_2, 11:00, 5h
    안정화 알고리즘                 :d3_3, 16:00, 0.5h
    
    section Day 4
    최종 최적화                     :d4_1, 09:00, 1h
    발표 (알고리즘 설명)             :d4_2, 10:00, 3h
```

---

## 14. 다음 문서 가이드

### 필수 읽기 (알고리즘 관점)
1. **curriculum/교육_커리큘럼_상편_Day1-2.md** ← 알고리즘 상세 설명
2. **curriculum/교육_커리큘럼_하편_Day3-4.md** ← 통합 알고리즘
3. **02_블루투스_프로토콜.md** ← 통신 프로토콜 알고리즘
4. **03_아두이노_피지컬컴퓨팅_가이드.md** ← 제어 알고리즘

### 참고 자료
- **03_바이브_코딩_가이드.md** ← 알고리즘 설계 방법론
- **04_피지컬AI_학습방법.md** ← AI 알고리즘
- **06_프로젝트_아이디어_모음.md** ← 응용 알고리즘

---

## 💬 FAQ (알고리즘 관점)

**Q: 상태 머신이 왜 필요한가요?**  
A: 복잡한 시스템을 **명확한 상태로 분리**하여 관리하기 위해서입니다. if문 덩어리보다 **확장성**과 **디버깅**이 훨씬 쉽습니다.

**Q: 시간 복잡도를 왜 분석하나요?**  
A: 실시간 시스템에서는 **응답 시간**이 중요합니다. 병목 지점을 찾아서 최적화해야 합니다.

**Q: 의사코드를 왜 먼저 작성하나요?**  
A: 코드 문법에 신경 쓰지 않고 **알고리즘 로직에만 집중**할 수 있습니다. 설계 단계에서 오류를 찾는 것이 구현 후보다 **10배 빠릅니다**.

**Q: 알고리즘을 배우면 다른 프로젝트에도 쓸 수 있나요?**  
A: 네! **상태 머신**, **필터링**, **프로토콜 파싱** 등은 모든 임베디드 시스템에서 사용됩니다.

---

**Last Updated**: 2026-01-22  
**Version**: 2.0 (알고리즘 중심 아키텍처)  
**제작**: Smart Factory Education Team  
**교구재**: [BP Lab AI 로봇팔](https://bplab.kr/order/?idx=178)
