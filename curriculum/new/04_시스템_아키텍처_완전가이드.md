# 🏗️ 스마트 팩토리 시스템 아키텍처 완전 가이드

> **"구조를 이해하면 시스템이 보인다"**

---

## 📌 문서 개요

### 목적
이 문서는 **알고리즘과 구조 중심**으로 스마트 팩토리 시스템의 전체 아키텍처를 설명합니다.

### 대상 독자
- 시스템 설계를 이해하고 싶은 학습자
- 개발 프로세스를 배우고 싶은 메이커
- 확장 및 개선을 계획하는 개발자

### 문서 구성

```mermaid
mindmap
  root((아키텍처<br/>가이드))
    전체 구조
      계층 구조
      모듈 구성
      데이터 흐름
    모듈별 상세
      로봇팔
      컨베이어
      AI
      앱
    핵심 알고리즘
      제어
      통신
      인식
      최적화
    통합 전략
      인터페이스
      프로토콜
      동기화
```

---

## 🌐 시스템 전체 구조

### 계층 아키텍처 (Layered Architecture)

```mermaid
graph TB
    subgraph Layer_7[L7: 사용자 인터페이스]
        UI[스마트폰 앱<br/>터치 인터페이스]
    end
    
    subgraph Layer_6[L6: 애플리케이션]
        APP[앱인벤터 앱<br/>비즈니스 로직]
        AI_UI[AI 인식 화면]
        CONTROL_UI[제어 화면]
        STATS_UI[통계 화면]
    end
    
    subgraph Layer_5[L5: AI/ML]
        TM[Teachable Machine<br/>이미지 분류 모델]
        TMIC[TMIC Extension<br/>추론 엔진]
    end
    
    subgraph Layer_4[L4: 통신]
        BT[Bluetooth<br/>HC-06]
        SERIAL[UART<br/>시리얼 통신]
        PROTOCOL[프로토콜<br/>파서]
    end
    
    subgraph Layer_3[L3: 제어 로직]
        MAIN[메인 컨트롤러<br/>Arduino]
        STATE[상태 머신]
        COMMAND[명령 처리기]
    end
    
    subgraph Layer_2[L2: 구동/센서]
        ROBOT[로봇팔<br/>Servo × 4]
        CONV[컨베이어<br/>DC Motor]
        IR[IR 센서]
        COLOR[컬러 센서]
    end
    
    subgraph Layer_1[L1: 하드웨어]
        PWR[전원<br/>12V + 5V]
        PIN[핀 매핑]
        WIRE[배선]
    end
    
    UI --> APP
    APP --> AI_UI & CONTROL_UI & STATS_UI
    AI_UI --> TM --> TMIC
    TMIC --> BT
    CONTROL_UI --> BT
    STATS_UI --> BT
    
    BT --> SERIAL --> PROTOCOL
    PROTOCOL --> MAIN
    MAIN --> STATE --> COMMAND
    
    COMMAND --> ROBOT & CONV
    IR & COLOR --> MAIN
    
    ROBOT & CONV & IR & COLOR --> PWR & PIN & WIRE
    
    style Layer_7 fill:#FFE3E3,color:#111
    style Layer_6 fill:#FFF3E0,color:#111
    style Layer_5 fill:#E8F5E9,color:#111
    style Layer_4 fill:#E3F2FD,color:#111
    style Layer_3 fill:#F3E5F5,color:#111
    style Layer_2 fill:#FFF9C4,color:#111
    style Layer_1 fill:#E0E0E0,color:#111
```

### 시스템 블록 다이어그램

```mermaid
graph LR
    subgraph 입력[입력 Input]
        CAMERA[카메라<br/>이미지]
        TOUCH[터치<br/>명령]
        IR_IN[IR 센서<br/>신호]
        COLOR_IN[컬러 센서<br/>RGB]
    end
    
    subgraph 처리[처리 Processing]
        AI_PROC[AI 추론]
        CMD_PROC[명령 처리]
        SENSOR_PROC[센서 처리]
        DECISION[의사결정<br/>알고리즘]
    end
    
    subgraph 출력[출력 Output]
        ROBOT_OUT[로봇팔<br/>동작]
        CONV_OUT[컨베이어<br/>동작]
        GATE_OUT[게이트<br/>동작]
        UI_OUT[UI 업데이트]
    end
    
    CAMERA --> AI_PROC
    TOUCH --> CMD_PROC
    IR_IN --> SENSOR_PROC
    COLOR_IN --> SENSOR_PROC
    
    AI_PROC --> DECISION
    CMD_PROC --> DECISION
    SENSOR_PROC --> DECISION
    
    DECISION --> ROBOT_OUT
    DECISION --> CONV_OUT
    DECISION --> GATE_OUT
    DECISION --> UI_OUT
    
    style 입력 fill:#E3F2FD,color:#111
    style 처리 fill:#FFD93D,color:#111
    style 출력 fill:#C8E6C9,color:#111
```

---

## 🤖 모듈 1: 로봇팔 시스템

### 로봇팔 아키텍처

#### 하드웨어 구조

```mermaid
graph TD
    subgraph 기계부[기계 구조]
        BASE[베이스<br/>Base]
        SHOULDER[어깨<br/>Shoulder]
        ELBOW[팔꿈치<br/>Elbow]
        GRIPPER[그리퍼<br/>Gripper]
    end
    
    subgraph 구동부[구동 시스템]
        SERVO1[Servo 1<br/>180도]
        SERVO2[Servo 2<br/>180도]
        SERVO3[Servo 3<br/>180도]
        SERVO4[Servo 4<br/>90도]
    end
    
    subgraph 제어부[제어 시스템]
        PWM1[PWM 신호<br/>D6]
        PWM2[PWM 신호<br/>D9]
        PWM3[PWM 신호<br/>D10]
        PWM4[PWM 신호<br/>D11]
    end
    
    BASE --> SERVO1 --> PWM1
    SHOULDER --> SERVO2 --> PWM2
    ELBOW --> SERVO3 --> PWM3
    GRIPPER --> SERVO4 --> PWM4
    
    PWM1 & PWM2 & PWM3 & PWM4 --> ARD[Arduino<br/>제어]
    
    style 기계부 fill:#FFEBEE,color:#111
    style 구동부 fill:#FFF3E0,color:#111
    style 제어부 fill:#E3F2FD,color:#111
```

#### 좌표 시스템

```mermaid
graph TD
    subgraph 베이스_좌표계[베이스 좌표계 Base Frame]
        O[원점 O<br/>0, 0, 0]
        X[X축: 전방<br/>Forward]
        Y[Y축: 좌측<br/>Left]
        Z[Z축: 상방<br/>Up]
    end
    
    subgraph 관절_공간[관절 공간 Joint Space]
        THETA1[θ₁: Base<br/>0-180°]
        THETA2[θ₂: Shoulder<br/>0-180°]
        THETA3[θ₃: Elbow<br/>0-180°]
        THETA4[θ₄: Gripper<br/>0-90°]
    end
    
    subgraph 작업_공간[작업 공간 Task Space]
        PX[X 좌표<br/>-30cm ~ +30cm]
        PY[Y 좌표<br/>-30cm ~ +30cm]
        PZ[Z 좌표<br/>0cm ~ 40cm]
    end
    
    O --> THETA1 & THETA2 & THETA3 & THETA4
    THETA1 & THETA2 & THETA3 & THETA4 --> FK[정기구학<br/>Forward Kinematics]
    FK --> PX & PY & PZ
    
    PX & PY & PZ --> IK[역기구학<br/>Inverse Kinematics]
    IK --> THETA1 & THETA2 & THETA3 & THETA4
    
    style 베이스_좌표계 fill:#E3F2FD,color:#111
    style 관절_공간 fill:#FFD93D,color:#111
    style 작업_공간 fill:#C8E6C9,color:#111
```

### 핵심 알고리즘: 동기화 이동

#### 알고리즘 흐름

```mermaid
graph TD
    START[입력:<br/>targetAngles[4]] --> VALIDATE[각도 범위<br/>검증]
    
    VALIDATE --> CALC_DIST[각 축별<br/>거리 계산]
    CALC_DIST -.공식.-> FORMULA1["d[i] = |target[i] - current[i]|"]
    
    CALC_DIST --> FIND_MAX[최대 거리<br/>찾기]
    FIND_MAX -.공식.-> FORMULA2["maxDist = max(d[0], d[1], d[2], d[3])"]
    
    FIND_MAX --> CALC_STEPS[스텝 수<br/>결정]
    CALC_STEPS -.공식.-> FORMULA3["steps = maxDist / stepSize"]
    
    CALC_STEPS --> LOOP_START[FOR step = 1 TO steps]
    
    LOOP_START --> CALC_RATIO[진행 비율<br/>계산]
    CALC_RATIO -.공식.-> FORMULA4["ratio = step / steps"]
    
    CALC_RATIO --> INTERPOLATE[선형 보간<br/>계산]
    INTERPOLATE -.공식.-> FORMULA5["angle[i] = current[i] +<br/>(target[i] - current[i]) × ratio"]
    
    INTERPOLATE --> MOVE_ALL[4축 동시<br/>이동]
    MOVE_ALL --> DELAY[delay<br/>stepDelay ms]
    
    DELAY --> CHECK_LOOP{step < steps?}
    CHECK_LOOP -->|Yes| LOOP_START
    CHECK_LOOP -->|No| FINAL_POS[최종 위치<br/>보정]
    
    FINAL_POS --> UPDATE[currentAngles<br/>업데이트]
    UPDATE --> DONE[완료]
    
    style START fill:#99E9F2,color:#111
    style INTERPOLATE fill:#FFD93D,color:#111
    style DONE fill:#51CF66,color:#fff
```

#### 타이밍 다이어그램

```mermaid
gantt
    title 동기화 이동 타이밍 (90도 → 45도, 45도 → 90도)
    dateFormat X
    axisFormat %L ms
    
    section Axis 1 (Base)
    이동 45도: a1, 0, 45
    
    section Axis 2 (Shoulder)
    이동 45도: a2, 0, 45
    
    section Axis 3 (Elbow)
    대기: a3_wait, 0, 45
    
    section Axis 4 (Gripper)
    대기: a4_wait, 0, 45
    
    section Timing
    Step Delay 15ms: crit, 0, 15
    Step Delay 15ms: crit, 15, 30
    Step Delay 15ms: crit, 30, 45
```

### 상태 머신

```mermaid
stateDiagram-v2
    [*] --> IDLE: 전원 ON
    
    IDLE --> HOMING: HOME 명령
    HOMING --> IDLE: 완료
    
    IDLE --> MOVING: 이동 명령
    MOVING --> IDLE: 완료
    MOVING --> ERROR: 범위 초과
    
    IDLE --> PICKING: PICK 명령
    PICKING --> GRIPPING: 접근 완료
    GRIPPING --> LIFTING: 집기 완료
    LIFTING --> IDLE: 완료
    PICKING --> ERROR: 3회 실패
    
    IDLE --> PLACING: PLACE 명령
    PLACING --> RELEASING: 위치 도달
    RELEASING --> IDLE: 놓기 완료
    
    ERROR --> IDLE: 복구
    ERROR --> SAFE_MODE: 심각한 오류
    SAFE_MODE --> [*]: 재시작 필요
    
    note right of IDLE
        LED: 초록불
        모든 축 대기
    end note
    
    note right of ERROR
        LED: 빨강불
        부저: 경고음
    end note
```

---

## 🚛 모듈 2: 컨베이어 시스템

### 컨베이어 아키텍처

#### 하드웨어 구성

```mermaid
graph TD
    subgraph 기계부[기계 구조]
        BELT[벨트<br/>Belt]
        FRAME[프레임<br/>Frame]
        GATE[게이트<br/>Servo Gate]
    end
    
    subgraph 구동부[구동 시스템]
        DC[DC 모터<br/>12V]
        DRIVER[모터 드라이버<br/>L298N]
        GATE_SERVO[게이트 서보<br/>180도]
    end
    
    subgraph 센서부[센서 시스템]
        IR[IR 센서<br/>물체 감지]
        COLOR[TCS3200<br/>색상 센서]
        ULTRA[초음파<br/>거리 측정]
    end
    
    subgraph 제어부[제어 시스템]
        PWM_DC[PWM<br/>D5 ENA]
        DIR1[D3 IN1]
        DIR2[D4 IN2]
        PWM_GATE[PWM<br/>D12]
    end
    
    BELT --> DC --> DRIVER
    DRIVER --> PWM_DC & DIR1 & DIR2
    
    GATE --> GATE_SERVO --> PWM_GATE
    
    IR --> ARD[Arduino]
    COLOR --> ARD
    ULTRA --> ARD
    
    PWM_DC & DIR1 & DIR2 & PWM_GATE --> ARD
    
    style 기계부 fill:#FFEBEE,color:#111
    style 구동부 fill:#FFF3E0,color:#111
    style 센서부 fill:#E8F5E9,color:#111
    style 제어부 fill:#E3F2FD,color:#111
```

### 핵심 알고리즘: 색상 판단

#### TCS3200 센서 측정 알고리즘

```mermaid
graph TD
    START[측정 시작] --> SET_FREQ[주파수 스케일<br/>설정 20%]
    
    SET_FREQ --> MEASURE_R[RED 필터<br/>측정]
    MEASURE_R --> S2_L1[S2 = LOW]
    MEASURE_R --> S3_L1[S3 = LOW]
    S2_L1 & S3_L1 --> PULSE_R[pulseIn<br/>주파수 읽기]
    PULSE_R --> SAVE_R[R 값 저장]
    
    SAVE_R --> MEASURE_G[GREEN 필터<br/>측정]
    MEASURE_G --> S2_H[S2 = HIGH]
    MEASURE_G --> S3_H[S3 = HIGH]
    S2_H & S3_H --> PULSE_G[pulseIn]
    PULSE_G --> SAVE_G[G 값 저장]
    
    SAVE_G --> MEASURE_B[BLUE 필터<br/>측정]
    MEASURE_B --> S2_L2[S2 = LOW]
    MEASURE_B --> S3_H2[S3 = HIGH]
    S2_L2 & S3_H2 --> PULSE_B[pulseIn]
    PULSE_B --> SAVE_B[B 값 저장]
    
    SAVE_B --> FILTER[이동 평균<br/>필터 5회]
    FILTER --> NORMALIZE[정규화<br/>0-255]
    
    NORMALIZE --> CLASSIFY[색상 판단<br/>알고리즘]
    CLASSIFY --> RESULT[결과 반환<br/>RED/BLUE/YELLOW]
    
    style START fill:#99E9F2,color:#111
    style FILTER fill:#FFD93D,color:#111
    style RESULT fill:#51CF66,color:#fff
```

#### 유클리드 거리 계산

```mermaid
graph TD
    INPUT[측정 RGB<br/>r, g, b] --> REF[기준 RGB<br/>로드]
    
    REF --> REF_R[RED_REF<br/>r₁, g₁, b₁]
    REF --> REF_B[BLUE_REF<br/>r₂, g₂, b₂]
    REF --> REF_Y[YELLOW_REF<br/>r₃, g₃, b₃]
    
    INPUT & REF_R --> DIST_R[거리 계산]
    DIST_R -.공식.-> DR["d_red = √[(r-r₁)² + (g-g₁)² + (b-b₁)²]"]
    
    INPUT & REF_B --> DIST_B[거리 계산]
    DIST_B -.공식.-> DB["d_blue = √[(r-r₂)² + (g-g₂)² + (b-b₂)²]"]
    
    INPUT & REF_Y --> DIST_Y[거리 계산]
    DIST_Y -.공식.-> DY["d_yellow = √[(r-r₃)² + (g-g₃)² + (b-b₃)²]"]
    
    DIST_R & DIST_B & DIST_Y --> MIN[최소 거리<br/>찾기]
    MIN --> CHECK{< 임계값?}
    
    CHECK -->|Yes| COLOR[해당 색상<br/>반환]
    CHECK -->|No| UNKNOWN[UNKNOWN<br/>반환]
    
    style INPUT fill:#99E9F2,color:#111
    style MIN fill:#FFD93D,color:#111
    style COLOR fill:#51CF66,color:#fff
```

### 상태 머신

```mermaid
stateDiagram-v2
    [*] --> IDLE: 초기화
    
    IDLE --> RUNNING: START 명령
    RUNNING --> DETECTING: IR 센서 폴링
    
    DETECTING --> RUNNING: 물체 없음
    DETECTING --> STOPPED: 물체 감지
    
    STOPPED --> MEASURING: 100ms 대기
    MEASURING --> ANALYZING: RGB 측정 완료
    
    ANALYZING --> SORTING: 색상 판단 완료
    SORTING --> GATE_0: 빨강
    SORTING --> GATE_90: 파랑
    SORTING --> GATE_180: 노랑
    
    GATE_0 --> COUNTING: 2초 대기
    GATE_90 --> COUNTING
    GATE_180 --> COUNTING
    
    COUNTING --> RESET_GATE: 통계 업데이트
    RESET_GATE --> RUNNING: 게이트 복귀
    
    RUNNING --> IDLE: STOP 명령
    
    note right of DETECTING
        IR 센서 100ms 주기
        디바운싱 50ms
    end note
    
    note right of ANALYZING
        5회 측정 평균
        유클리드 거리 계산
    end note
```

---

## 🤖 모듈 3: AI 인식 시스템

### AI 시스템 아키텍처

#### 전체 파이프라인

```mermaid
graph LR
    subgraph 데이터_수집[데이터 수집]
        CAM[카메라<br/>촬영]
        IMG[이미지<br/>전처리]
    end
    
    subgraph 학습_단계[학습 단계]
        TM_TRAIN[Teachable Machine<br/>학습]
        VALID[검증<br/>Validation]
        EXPORT[모델 내보내기<br/>TensorFlow.js]
    end
    
    subgraph 배포_단계[배포 단계]
        CLOUD[클라우드<br/>호스팅]
        URL[모델 URL<br/>획득]
    end
    
    subgraph 추론_단계[추론 단계]
        APP_IMG[앱에서<br/>이미지 촬영]
        TMIC_INFER[TMIC<br/>추론 실행]
        RESULT[결과 반환<br/>label + confidence]
    end
    
    CAM --> IMG --> TM_TRAIN
    TM_TRAIN --> VALID --> EXPORT
    EXPORT --> CLOUD --> URL
    
    URL --> TMIC_INFER
    APP_IMG --> TMIC_INFER --> RESULT
    
    style 데이터_수집 fill:#E3F2FD,color:#111
    style 학습_단계 fill:#FFF3E0,color:#111
    style 배포_단계 fill:#F3E5F5,color:#111
    style 추론_단계 fill:#C8E6C9,color:#111
```

### 학습 알고리즘

#### 데이터 수집 전략

```mermaid
graph TD
    START[데이터 수집<br/>시작] --> DEFINE[클래스 정의<br/>3개]
    
    DEFINE --> STRATEGY[다양성 전략<br/>수립]
    
    STRATEGY --> VAR1[조명 변화<br/>3종]
    STRATEGY --> VAR2[각도 변화<br/>5종]
    STRATEGY --> VAR3[거리 변화<br/>3종]
    STRATEGY --> VAR4[배경 변화<br/>3종]
    
    VAR1 & VAR2 & VAR3 & VAR4 --> COLLECT[체계적 수집]
    
    COLLECT --> TARGET[목표 달성?<br/>100장/클래스]
    TARGET -->|No| COLLECT
    TARGET -->|Yes| QUALITY[품질 검증]
    
    QUALITY --> CHECK{불량 이미지?}
    CHECK -->|Yes| REMOVE[제거]
    REMOVE --> COLLECT
    CHECK -->|No| DONE[수집 완료]
    
    style START fill:#99E9F2,color:#111
    style STRATEGY fill:#FFD93D,color:#111
    style DONE fill:#51CF66,color:#fff
```

#### 학습 프로세스

```mermaid
graph TD
    DATA[학습 데이터<br/>준비] --> SPLIT[데이터 분할]
    
    SPLIT --> TRAIN_SET[Train Set<br/>80%]
    SPLIT --> VAL_SET[Validation Set<br/>20%]
    
    TRAIN_SET --> INIT[모델 초기화]
    INIT --> EPOCH_START[Epoch 시작]
    
    EPOCH_START --> FORWARD[Forward Pass<br/>예측]
    FORWARD --> LOSS[Loss 계산<br/>Cross-Entropy]
    LOSS -.공식.-> LOSS_F["L = -Σ y log(ŷ)"]
    
    LOSS --> BACKWARD[Backward Pass<br/>그래디언트]
    BACKWARD --> UPDATE[가중치 업데이트<br/>Adam Optimizer]
    UPDATE -.공식.-> UPDATE_F["w = w - α∇L"]
    
    UPDATE --> CHECK_EPOCH{Epoch<br/>완료?}
    CHECK_EPOCH -->|No| EPOCH_START
    CHECK_EPOCH -->|Yes| VALIDATE[검증]
    
    VAL_SET --> VALIDATE
    VALIDATE --> ACCURACY[정확도 계산]
    ACCURACY --> CHECK_ACC{90%<br/>이상?}
    
    CHECK_ACC -->|No| MORE_DATA[데이터 추가]
    MORE_DATA --> DATA
    CHECK_ACC -->|Yes| EXPORT[모델 내보내기]
    
    style DATA fill:#99E9F2,color:#111
    style LOSS fill:#FFD93D,color:#111
    style EXPORT fill:#51CF66,color:#fff
```

### 추론 알고리즘

```mermaid
graph TD
    START[이미지 입력<br/>224×224 RGB] --> PREPROCESS[전처리]
    
    PREPROCESS --> RESIZE[크기 조정]
    PREPROCESS --> NORMALIZE[정규화<br/>0-1]
    
    RESIZE & NORMALIZE --> MODEL[TensorFlow.js<br/>모델]
    
    MODEL --> CONV1[Conv Layer 1]
    CONV1 --> POOL1[Pooling 1]
    POOL1 --> CONV2[Conv Layer 2]
    CONV2 --> POOL2[Pooling 2]
    POOL2 --> FC[Fully Connected]
    FC --> SOFTMAX[Softmax]
    
    SOFTMAX --> OUTPUT[출력<br/>Class Probabilities]
    OUTPUT -.예시.-> EX["[RED: 0.95,<br/>BLUE: 0.03,<br/>YELLOW: 0.02]"]
    
    OUTPUT --> ARGMAX[최대값 찾기]
    ARGMAX --> RESULT[label: RED<br/>confidence: 0.95]
    
    style START fill:#99E9F2,color:#111
    style MODEL fill:#FFD93D,color:#111
    style RESULT fill:#51CF66,color:#fff
```

---

## 📱 모듈 4: 앱인벤터 앱

### 앱 아키텍처

#### MVC 패턴

```mermaid
graph TD
    subgraph Model[Model 데이터]
        STATE[시스템 상태]
        STATS[통계 데이터]
        CONFIG[설정]
    end
    
    subgraph View[View UI]
        SCREEN1[Screen1]
        TAB_AI[AI 인식 탭]
        TAB_CTRL[수동 제어 탭]
        TAB_STATS[통계 탭]
    end
    
    subgraph Controller[Controller 로직]
        EVENT[이벤트 핸들러]
        COMMAND[명령 생성기]
        UPDATE[UI 업데이터]
    end
    
    View --> EVENT
    EVENT --> COMMAND
    COMMAND --> Model
    Model --> UPDATE
    UPDATE --> View
    
    style Model fill:#E3F2FD,color:#111
    style View fill:#FFF3E0,color:#111
    style Controller fill:#C8E6C9,color:#111
```

#### 화면 구성

```mermaid
graph TD
    APP[App Start] --> SPLASH[Splash Screen<br/>2초]
    SPLASH --> MAIN[Main Screen]
    
    MAIN --> TAB1[Tab 1:<br/>AI 인식]
    MAIN --> TAB2[Tab 2:<br/>수동 제어]
    MAIN --> TAB3[Tab 3:<br/>통계]
    
    TAB1 --> CAMERA[Camera<br/>Component]
    TAB1 --> TMIC[TMIC<br/>Extension]
    TAB1 --> IMG[Image<br/>Display]
    TAB1 --> RESULT[Result<br/>Label]
    TAB1 --> ZONE[Zone<br/>Spinner]
    
    TAB2 --> SLIDER1[Slider<br/>Base]
    TAB2 --> SLIDER2[Slider<br/>Shoulder]
    TAB2 --> SLIDER3[Slider<br/>Elbow]
    TAB2 --> SLIDER4[Slider<br/>Gripper]
    TAB2 --> BTN_SEND[Send<br/>Button]
    
    TAB3 --> CHART[Pie Chart]
    TAB3 --> TABLE[Statistics<br/>Table]
    TAB3 --> BTN_RESET[Reset<br/>Button]
    
    MAIN --> BT[BluetoothClient]
    MAIN --> CLOCK[Clock<br/>Timer 1s]
    
    style APP fill:#99E9F2,color:#111
    style MAIN fill:#FFD93D,color:#111
```

### 핵심 알고리즘: 이벤트 처리

#### AI 인식 플로우

```mermaid
sequenceDiagram
    participant User
    participant Button
    participant Camera
    participant TMIC
    participant Bluetooth
    participant Arduino
    
    User->>Button: 촬영 버튼 클릭
    Button->>Camera: TakePicture()
    Camera->>Camera: 사진 촬영
    Camera->>TMIC: AfterPicture(image)
    
    TMIC->>TMIC: 이미지 전처리
    TMIC->>TMIC: 모델 추론
    
    alt confidence > 0.8
        TMIC->>User: GotClassification(label, conf)
        User->>Button: Zone 선택 + 전송
        Button->>Bluetooth: SendText("AI_RED_1")
        Bluetooth->>Arduino: 명령 전달
        Arduino-->>Bluetooth: "OK:PICK"
        Bluetooth-->>User: 결과 표시
    else confidence <= 0.8
        TMIC->>User: "재촬영 필요"
    end
```

#### 블록 코딩 구조

```mermaid
graph TD
    INIT[Screen.Initialize] --> SETUP[초기 설정]
    
    SETUP --> LOAD_MODEL[TMIC.ModelURL<br/>설정]
    SETUP --> CONNECT_BT[Bluetooth<br/>연결 시도]
    SETUP --> START_TIMER[Clock.Timer<br/>시작]
    
    CLICK[Button_Capture.Click] --> TAKE[Camera.TakePicture]
    
    AFTER[Camera.AfterPicture] --> SHOW_IMG[Image.Picture<br/>← image]
    SHOW_IMG --> CLASSIFY[TMIC.ClassifyImage]
    
    GOT[TMIC.GotClassification] --> CHECK_CONF{confidence<br/> > 0.8?}
    CHECK_CONF -->|Yes| SHOW_RESULT[Label 업데이트]
    CHECK_CONF -->|No| RETRY[재촬영 요청]
    
    SHOW_RESULT --> GET_ZONE[Spinner 값 읽기]
    GET_ZONE --> BUILD_CMD[명령 문자열<br/>생성]
    BUILD_CMD -.예시.-> CMD_EX["AI_RED_1"]
    
    BUILD_CMD --> SEND[Bluetooth.SendText]
    
    TIMER[Clock.Timer] --> REQUEST[상태 요청<br/>"?"]
    REQUEST --> RECEIVE[Bluetooth.ReceiveText]
    RECEIVE --> PARSE[데이터 파싱]
    PARSE --> UPDATE_UI[UI 업데이트]
    
    style INIT fill:#99E9F2,color:#111
    style CLASSIFY fill:#FFD93D,color:#111
    style SEND fill:#51CF66,color:#fff
```

---

## 🔗 통신 프로토콜

### 블루투스 프로토콜 명세

#### 명령 프로토콜

```mermaid
graph TD
    subgraph 앱_to_아두이노[앱 → 아두이노]
        CMD1[AI_color_zone<br/>예: AI_RED_1]
        CMD2[MANUAL_a,b,c,d<br/>예: MANUAL_90,90,90,0]
        CMD3[SENSOR_AUTO<br/>센서 자동 모드]
        CMD4[?<br/>상태 조회]
        CMD5[RESET<br/>초기화]
    end
    
    subgraph 아두이노_to_앱[아두이노 → 앱]
        RESP1[OK:action<br/>예: OK:PICK]
        RESP2[ERR:message<br/>예: ERR:FAIL]
        RESP3[STATUS:state<br/>예: STATUS:IDLE]
        RESP4[JSON<br/>통계 데이터]
    end
    
    CMD1 & CMD2 & CMD3 & CMD4 & CMD5 --> PARSE[파싱]
    PARSE --> EXECUTE[실행]
    EXECUTE --> RESP1 & RESP2 & RESP3 & RESP4
    
    style 앱_to_아두이노 fill:#E3F2FD,color:#111
    style 아두이노_to_앱 fill:#C8E6C9,color:#111
```

#### 프로토콜 상세 명세

| 방향 | 명령 | 형식 | 예시 | 설명 |
|------|------|------|------|------|
| 앱→아두이노 | AI 피킹 | `AI_<COLOR>_<ZONE>` | `AI_RED_1` | AI 인식 결과로 피킹 |
| 앱→아두이노 | 수동 제어 | `MANUAL_<a>,<b>,<c>,<d>` | `MANUAL_90,90,90,0` | 각도 직접 제어 |
| 앱→아두이노 | 센서 자동 | `SENSOR_AUTO` | `SENSOR_AUTO` | 센서 기반 자동 분류 |
| 앱→아두이노 | 상태 조회 | `?` | `?` | 현재 상태 요청 |
| 앱→아두이노 | 홈 포지션 | `H` | `H` | 홈으로 복귀 |
| 아두이노→앱 | 성공 응답 | `OK:<ACTION>` | `OK:PICK` | 명령 실행 성공 |
| 아두이노→앱 | 오류 응답 | `ERR:<MESSAGE>` | `ERR:FAIL` | 명령 실행 실패 |
| 아두이노→앱 | 상태 응답 | `STATUS:<STATE>` | `STATUS:IDLE` | 현재 상태 |
| 아두이노→앱 | 통계 JSON | `{"red":5,"blue":3}` | JSON 문자열 | 실시간 통계 |

### 데이터 흐름

```mermaid
sequenceDiagram
    participant App as 앱
    participant BT as 블루투스
    participant Parse as 파서
    participant State as 상태머신
    participant Robot as 로봇팔
    participant Sensor as 센서
    
    Note over App,Sensor: 초기 연결
    App->>BT: 페어링 요청
    BT-->>App: 연결 성공
    
    Note over App,Sensor: AI 명령 전송
    App->>BT: "AI_RED_1\n"
    BT->>Parse: 시리얼 수신
    Parse->>State: parseCommand()
    State->>Robot: pickFromZone(1, "RED")
    Robot-->>State: 완료
    State->>BT: "OK:PICK\n"
    BT-->>App: 응답 수신
    
    Note over App,Sensor: 주기적 상태 업데이트
    loop 1초마다
        State->>BT: JSON 통계
        BT->>App: 수신
        App->>App: UI 업데이트
    end
    
    Note over App,Sensor: 센서 이벤트
    Sensor->>State: IR 감지
    State->>Sensor: 색상 측정
    Sensor-->>State: RGB 값
    State->>State: 색상 판단
    State->>BT: JSON 업데이트
    BT->>App: 수신
```

---

## ⚙️ 핵심 알고리즘 모음

### 1. 제어 알고리즘

#### PID 제어 (선택적)

```mermaid
graph TD
    TARGET[목표값<br/>Target] --> ERROR[오차 계산<br/>e = target - current]
    CURRENT[현재값<br/>Current] --> ERROR
    
    ERROR --> P[비례 P<br/>Kp × e]
    ERROR --> I[적분 I<br/>Ki × Σe]
    ERROR --> D[미분 D<br/>Kd × Δe]
    
    P & I & D --> SUM[합산]
    SUM --> OUTPUT[제어 출력]
    
    OUTPUT --> ACTUATOR[액츄에이터]
    ACTUATOR --> FEEDBACK[피드백]
    FEEDBACK --> CURRENT
    
    style TARGET fill:#99E9F2,color:#111
    style SUM fill:#FFD93D,color:#111
    style OUTPUT fill:#51CF66,color:#fff
```

### 2. 필터 알고리즘

#### 이동 평균 필터

```mermaid
graph TD
    NEW[새 샘플<br/>입력] --> BUFFER[순환 버퍼]
    BUFFER -.크기.-> SIZE[windowSize = 5]
    
    BUFFER --> ADD[버퍼에 추가]
    ADD --> FULL{버퍼<br/>가득?}
    FULL -->|No| WAIT[대기]
    FULL -->|Yes| SUM[합계 계산]
    
    SUM --> AVG[평균 계산]
    AVG -.공식.-> FORMULA["avg = Σsamples / windowSize"]
    
    AVG --> OUTPUT[필터링된<br/>값 출력]
    
    style NEW fill:#99E9F2,color:#111
    style AVG fill:#FFD93D,color:#111
    style OUTPUT fill:#51CF66,color:#fff
```

#### 칼만 필터 (고급)

```mermaid
graph TD
    PREDICT[예측 단계<br/>Prediction] --> P1[상태 예측<br/>x̂ = Ax + Bu]
    P1 --> P2[오차 예측<br/>P = APA' + Q]
    
    UPDATE[업데이트 단계<br/>Update] --> U1[칼만 이득<br/>K = PH'/(HPH'+R)]
    U1 --> U2[상태 업데이트<br/>x̂ = x̂ + K(z-Hx̂)]
    U2 --> U3[오차 업데이트<br/>P = (I-KH)P]
    
    P2 --> UPDATE
    U3 --> PREDICT
    
    style PREDICT fill:#FFD93D,color:#111
    style UPDATE fill:#FFA94D,color:#111
```

### 3. 의사결정 알고리즘

#### 규칙 기반 시스템

```mermaid
graph TD
    INPUT[입력<br/>센서 데이터] --> RULE1{규칙 1:<br/>IR 감지?}
    
    RULE1 -->|Yes| RULE2{규칙 2:<br/>색상 판단}
    RULE1 -->|No| IDLE[대기]
    
    RULE2 -->|빨강| ACTION1[게이트 0도]
    RULE2 -->|파랑| ACTION2[게이트 90도]
    RULE2 -->|노랑| ACTION3[게이트 180도]
    RULE2 -->|기타| ERROR[오류 처리]
    
    ACTION1 & ACTION2 & ACTION3 --> OUTPUT[실행]
    
    style INPUT fill:#99E9F2,color:#111
    style RULE1 fill:#FFD93D,color:#111
    style OUTPUT fill:#51CF66,color:#fff
```

---

## 🔄 시스템 통합 전략

### 모듈 통합 순서

```mermaid
graph TD
    START[개별 모듈<br/>개발 완료] --> INT1[통합 1단계]
    
    INT1 --> STEP1[로봇팔 + 앱<br/>블루투스 연결]
    STEP1 --> TEST1[기본 제어<br/>테스트]
    TEST1 --> VERIFY1{성공?}
    VERIFY1 -->|No| DEBUG1[디버깅]
    DEBUG1 --> STEP1
    VERIFY1 -->|Yes| INT2
    
    INT2[통합 2단계] --> STEP2[컨베이어 + 센서<br/>추가]
    STEP2 --> TEST2[센서 연동<br/>테스트]
    TEST2 --> VERIFY2{성공?}
    VERIFY2 -->|No| DEBUG2[디버깅]
    DEBUG2 --> STEP2
    VERIFY2 -->|Yes| INT3
    
    INT3[통합 3단계] --> STEP3[AI 모델<br/>연동]
    STEP3 --> TEST3[AI 추론<br/>테스트]
    TEST3 --> VERIFY3{성공?}
    VERIFY3 -->|No| DEBUG3[디버깅]
    DEBUG3 --> STEP3
    VERIFY3 -->|Yes| INT4
    
    INT4[통합 4단계] --> STEP4[전체 시스템<br/>통합]
    STEP4 --> TEST4[End-to-End<br/>테스트]
    TEST4 --> VERIFY4{성공?}
    VERIFY4 -->|No| DEBUG4[최적화]
    DEBUG4 --> STEP4
    VERIFY4 -->|Yes| DONE[통합 완료]
    
    style START fill:#99E9F2,color:#111
    style INT1 fill:#FFD93D,color:#111
    style INT2 fill:#FFD93D,color:#111
    style INT3 fill:#FFD93D,color:#111
    style INT4 fill:#FFD93D,color:#111
    style DONE fill:#51CF66,color:#fff
```

### 인터페이스 설계 원칙

```mermaid
graph TD
    PRINCIPLE[인터페이스<br/>설계 원칙] --> P1[명확성<br/>Clear]
    PRINCIPLE --> P2[일관성<br/>Consistent]
    PRINCIPLE --> P3[최소성<br/>Minimal]
    PRINCIPLE --> P4[견고성<br/>Robust]
    
    P1 --> E1[명확한 입출력<br/>정의]
    P2 --> E2[프로토콜<br/>표준화]
    P3 --> E3[최소 의존성<br/>유지]
    P4 --> E4[오류 처리<br/>필수]
    
    style PRINCIPLE fill:#FFD93D,color:#111
```

---

## 📈 성능 최적화

### 병목 지점 분석

```mermaid
graph TD
    PROFILE[프로파일링] --> MEASURE[시간 측정]
    
    MEASURE --> T1[로봇팔 이동<br/>5초]
    MEASURE --> T2[AI 추론<br/>3초]
    MEASURE --> T3[센서 측정<br/>1초]
    MEASURE --> T4[통신<br/>0.5초]
    
    T1 & T2 & T3 & T4 --> ANALYZE[분석]
    ANALYZE --> BOTTLENECK[병목: AI 추론<br/>3초]
    
    BOTTLENECK --> OPTIMIZE[최적화 전략]
    OPTIMIZE --> O1[이미지 크기<br/>감소]
    OPTIMIZE --> O2[모델 경량화<br/>선택]
    OPTIMIZE --> O3[비동기 처리]
    
    O1 & O2 & O3 --> RETEST[재측정]
    RETEST --> IMPROVED[개선: 1.5초<br/>50% 향상]
    
    style BOTTLENECK fill:#FF6B6B,color:#fff
    style IMPROVED fill:#51CF66,color:#fff
```

---

## 🎓 확장 가능성

### 시스템 확장 로드맵

```mermaid
graph TD
    CURRENT[현재 시스템<br/>3일 완성] --> EXPAND[확장 방향]
    
    EXPAND --> EXP1[하드웨어<br/>확장]
    EXPAND --> EXP2[소프트웨어<br/>확장]
    EXPAND --> EXP3[AI<br/>확장]
    
    EXP1 --> H1[6축 로봇팔]
    EXP1 --> H2[비전 카메라]
    EXP1 --> H3[다중 센서]
    
    EXP2 --> S1[클라우드 연동]
    EXP2 --> S2[웹 대시보드]
    EXP2 --> S3[데이터베이스]
    
    EXP3 --> A1[객체 검출]
    EXP3 --> A2[강화학습]
    EXP3 --> A3[예측 유지보수]
    
    style CURRENT fill:#FFD93D,color:#111
    style EXP1 fill:#99E9F2,color:#111
    style EXP2 fill:#FFA94D,color:#111
    style EXP3 fill:#C8E6C9,color:#111
```

---

**시스템 아키텍처 가이드 완료!** 🎉

이제 구조를 이해했으니, 원리를 파악하고, 창의적으로 확장할 수 있습니다!

---

**Last Updated**: 2026-01-25  
**Version**: 1.0 (알고리즘 중심 아키텍처)  
**제작**: Smart Factory Education Team
